
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/matthieu/mcp-server-prtg/cmd/server/main.go (0.0%)</option>
				
				<option value="file1">github.com/matthieu/mcp-server-prtg/cmd/server/service.go (0.0%)</option>
				
				<option value="file2">github.com/matthieu/mcp-server-prtg/internal/agent/agent.go (0.0%)</option>
				
				<option value="file3">github.com/matthieu/mcp-server-prtg/internal/cliArgs/args.go (0.0%)</option>
				
				<option value="file4">github.com/matthieu/mcp-server-prtg/internal/config/config.go (0.0%)</option>
				
				<option value="file5">github.com/matthieu/mcp-server-prtg/internal/database/db.go (0.0%)</option>
				
				<option value="file6">github.com/matthieu/mcp-server-prtg/internal/database/queries.go (0.0%)</option>
				
				<option value="file7">github.com/matthieu/mcp-server-prtg/internal/handlers/tools.go (0.0%)</option>
				
				<option value="file8">github.com/matthieu/mcp-server-prtg/internal/server/sse_server_v2.go (0.0%)</option>
				
				<option value="file9">github.com/matthieu/mcp-server-prtg/internal/services/configuration/config.go (0.0%)</option>
				
				<option value="file10">github.com/matthieu/mcp-server-prtg/internal/services/logger/logger.go (0.0%)</option>
				
				<option value="file11">github.com/matthieu/mcp-server-prtg/internal/services/logger/masking.go (0.0%)</option>
				
				<option value="file12">github.com/matthieu/mcp-server-prtg/internal/types/models.go (0.0%)</option>
				
				<option value="file13">github.com/matthieu/mcp-server-prtg/internal/version/version.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "os"
        "path/filepath"
        "time"

        "github.com/matthieu/mcp-server-prtg/internal/cliArgs"
        "github.com/matthieu/mcp-server-prtg/internal/services/configuration"
        "github.com/matthieu/mcp-server-prtg/internal/services/logger"
        "github.com/matthieu/mcp-server-prtg/internal/version"
)

// Build-time variables injected via ldflags.
var (
        Version    = "v1.0.0"  // Injected via -X flag at build time
        CommitHash = "unknown" // Injected via -X flag at build time
        BuildTime  = "unknown" // Injected via -X flag at build time
        GoVersion  = "unknown" // Injected via -X flag at build time
)

const (
        cmdRun       = "run"
        cmdInstall   = "install"
        cmdUninstall = "uninstall"
        cmdStart     = "start"
        cmdStop      = "stop"
        cmdStatus    = "status"
        cmdConfig    = "config"
)

func main() <span class="cov0" title="0">{
        // Initialize application version
        version.Set(Version)

        // Parse CLI arguments with version info
        args := cliArgs.ParseWithVersion(getVersionString())

        // Execute command
        if err := executeCommand(args); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}

// executeCommand executes the specified command.
func executeCommand(args *cliArgs.ParsedArgs) error <span class="cov0" title="0">{
        // If no command provided, show help
        if args.Command == "" </span><span class="cov0" title="0">{
                return showHelp()
        }</span>

        <span class="cov0" title="0">switch args.Command </span>{
        case cmdRun:<span class="cov0" title="0">
                // Run via service framework (handles both console and service mode)
                return runService(args)</span>

        case cmdInstall:<span class="cov0" title="0">
                fmt.Println("Installing MCP Server PRTG as system service...")

                // Ensure configuration exists before installing service
                if err := ensureConfiguration(args); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create configuration: %w", err)
                }</span>

                <span class="cov0" title="0">if err := installService(args); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to install service: %w", err)
                }</span>
                <span class="cov0" title="0">fmt.Println("✓ Service installed successfully")
                fmt.Printf("  Configuration: %s\n", args.ConfigPath)
                fmt.Printf("  Use '%s start' to start the service\n", os.Args[0])
                return nil</span>

        case cmdUninstall:<span class="cov0" title="0">
                fmt.Println("Uninstalling MCP Server PRTG service...")
                if err := uninstallService(args); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to uninstall service: %w", err)
                }</span>
                <span class="cov0" title="0">fmt.Println("✓ Service uninstalled successfully")
                return nil</span>

        case cmdStart:<span class="cov0" title="0">
                fmt.Println("Starting MCP Server PRTG service...")
                if err := startService(args); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to start service: %w", err)
                }</span>
                <span class="cov0" title="0">fmt.Println("✓ Service started successfully")
                // Wait a bit and check status
                time.Sleep(2 * time.Second)
                return getServiceStatus(args)</span>

        case cmdStop:<span class="cov0" title="0">
                fmt.Println("Stopping MCP Server PRTG service...")
                if err := stopService(args); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to stop service: %w", err)
                }</span>
                <span class="cov0" title="0">fmt.Println("✓ Service stopped successfully")
                return nil</span>

        case cmdStatus:<span class="cov0" title="0">
                return getServiceStatus(args)</span>

        case cmdConfig:<span class="cov0" title="0">
                return handleConfigCommand(args)</span>

        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown command: %s\n\nAvailable commands: run, install, uninstall, start, stop, status, config", args.Command)</span>
        }
}

// handleConfigCommand handles config-related commands.
func handleConfigCommand(args *cliArgs.ParsedArgs) error <span class="cov0" title="0">{
        fmt.Println("Configuration management")
        fmt.Printf("  Config file: %s\n", args.ConfigPath)
        fmt.Println("\nTo generate a new configuration file, run:")
        fmt.Printf("  %s run --config %s\n", os.Args[0], args.ConfigPath)
        fmt.Println("\nThis will create a new config with auto-generated API key and TLS certificates.")
        return nil
}</span>

// getVersionString returns the full version string.
func getVersionString() string <span class="cov0" title="0">{
        return fmt.Sprintf("mcp-server-prtg %s (commit: %s, built: %s, %s)",
                Version, CommitHash, BuildTime, GoVersion)
}</span>

// ensureConfiguration creates configuration file if it doesn't exist.
func ensureConfiguration(args *cliArgs.ParsedArgs) error <span class="cov0" title="0">{
        // Check if config file already exists
        if _, err := os.Stat(args.ConfigPath); err == nil </span><span class="cov0" title="0">{
                fmt.Printf("  Configuration file already exists: %s\n", args.ConfigPath)
                return nil
        }</span>

        // Create directory for config file if needed
        <span class="cov0" title="0">configDir := filepath.Dir(args.ConfigPath)
        if err := os.MkdirAll(configDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config directory: %w", err)
        }</span>

        // Create silent logger for config generation (no console output)
        <span class="cov0" title="0">tempLogger := logger.NewSilentLogger()

        // Create configuration (will generate default if not exists)
        config, err := configuration.NewConfiguration(args, tempLogger)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create configuration: %w", err)
        }</span>

        // Shutdown config to close file watcher
        <span class="cov0" title="0">_ = config.Shutdown(nil)

        fmt.Printf("  ✓ Configuration file created: %s\n", args.ConfigPath)
        fmt.Printf("  ✓ API Key generated (see config file)\n")
        if config.IsTLSEnabled() </span><span class="cov0" title="0">{
                fmt.Printf("  ✓ TLS certificates generated\n")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// showHelp displays usage information.
func showHelp() error <span class="cov0" title="0">{
        fmt.Printf("MCP Server PRTG - %s\n\n", getVersionString())
        fmt.Println("USAGE:")
        fmt.Printf("  %s &lt;command&gt; [options]\n\n", os.Args[0])
        fmt.Println("COMMANDS:")
        fmt.Println("  run         Run the server in console mode (foreground)")
        fmt.Println("  install     Install as system service")
        fmt.Println("  uninstall   Uninstall system service")
        fmt.Println("  start       Start the system service")
        fmt.Println("  stop        Stop the system service")
        fmt.Println("  status      Show service status")
        fmt.Println("  config      Show configuration information")
        fmt.Println()
        fmt.Println("OPTIONS:")
        fmt.Println("  --config PATH       Path to configuration file (default: ./config.yaml)")
        fmt.Println("  --db-password PASS  Database password (or set PRTG_DB_PASSWORD)")
        fmt.Println("  --version           Show version information")
        fmt.Println("  --help, -h          Show this help message")
        fmt.Println()
        fmt.Println("NOTE:")
        fmt.Println("  Log level is controlled via config.yaml (log_level: debug|info|warn|error)")
        fmt.Println()
        fmt.Println("EXAMPLES:")
        fmt.Printf("  %s run --config /etc/mcp-server-prtg/config.yaml\n", os.Args[0])
        fmt.Printf("  %s install --config /etc/mcp-server-prtg/config.yaml\n", os.Args[0])
        fmt.Printf("  %s start\n", os.Args[0])
        fmt.Println()
        fmt.Println("For more information, see: https://github.com/matthieu/mcp-server-prtg")
        return nil
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "fmt"
        "os"
        "os/signal"
        "path/filepath"
        "syscall"
        "time"

        "github.com/kardianos/service"
        "github.com/matthieu/mcp-server-prtg/internal/agent"
        "github.com/matthieu/mcp-server-prtg/internal/cliArgs"
        "github.com/matthieu/mcp-server-prtg/internal/database"
        "github.com/matthieu/mcp-server-prtg/internal/services/configuration"
        "github.com/matthieu/mcp-server-prtg/internal/services/logger"
)

// program implements the service.Interface.
type program struct {
        agent     *agent.Agent
        args      *cliArgs.ParsedArgs
        done      chan bool
        appLogger *logger.Logger
}

// Start is called when the service starts.
func (p *program) Start(_ service.Service) error <span class="cov0" title="0">{
        p.appLogger.Info().Msg("MCP Server PRTG service starting...")

        // Start agent initialization and execution in background
        // This allows the service to respond quickly to Windows Service Manager
        p.done = make(chan bool, 1)
        go p.run()

        return nil
}</span>

// run executes the agent (initialization + start).
func (p *program) run() <span class="cov0" title="0">{
        p.appLogger.Info().Msg("Initializing agent...")

        // Initialize agent (may take time due to DB connection attempts)
        var err error
        p.agent, err = agent.NewAgent(p.args)
        if err != nil </span><span class="cov0" title="0">{
                p.appLogger.Error().Err(err).Msg("Failed to create agent")
                p.done &lt;- true
                return
        }</span>

        <span class="cov0" title="0">p.appLogger.Info().Msg("Agent initialized successfully")

        // Start agent
        p.appLogger.Info().Msg("Starting agent server...")

        if err := p.agent.Start(); err != nil </span><span class="cov0" title="0">{
                p.appLogger.Error().Err(err).Msg("Agent error")
        }</span>

        <span class="cov0" title="0">p.appLogger.Info().Msg("Agent stopped")
        p.done &lt;- true</span>
}

// Stop is called when the service stops.
func (p *program) Stop(_ service.Service) error <span class="cov0" title="0">{
        // Graceful shutdown with timeout
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if p.agent != nil </span><span class="cov0" title="0">{
                if err := p.agent.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to shutdown agent: %w", err)
                }</span>
        }

        <span class="cov0" title="0">&lt;-p.done
        return nil</span>
}

// installService installs the service.
func installService(args *cliArgs.ParsedArgs) error <span class="cov0" title="0">{
        // Get executable directory
        execPath, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get executable path: %w", err)
        }</span>
        <span class="cov0" title="0">workingDir := filepath.Dir(execPath)

        // Create logs directory
        logFile := args.LogFile
        if !filepath.IsAbs(logFile) </span><span class="cov0" title="0">{
                logFile = filepath.Join(workingDir, logFile)
        }</span>
        <span class="cov0" title="0">logDir := filepath.Dir(logFile)

        if err := os.MkdirAll(logDir, 0750); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create log directory %s: %w", logDir, err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Log directory created: %s\n", logDir)
        fmt.Printf("   Logs will be written to: %s\n", logFile)

        svc, err := createService(args)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return svc.Install()</span>
}

// uninstallService uninstalls the service.
func uninstallService(args *cliArgs.ParsedArgs) error <span class="cov0" title="0">{
        svc, err := createService(args)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := svc.Uninstall(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Clean up configuration, logs, and certificates
        <span class="cov0" title="0">cleanupFiles(args)

        return nil</span>
}

// startService starts the service.
func startService(args *cliArgs.ParsedArgs) error <span class="cov0" title="0">{
        svc, err := createService(args)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return svc.Start()</span>
}

// stopService stops the service.
func stopService(args *cliArgs.ParsedArgs) error <span class="cov0" title="0">{
        svc, err := createService(args)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return svc.Stop()</span>
}

// runService runs the agent via service framework (handles both console and service mode).
// This is the correct way to run the agent in all contexts - exactly like senhub-agent.
func runService(args *cliArgs.ParsedArgs) error <span class="cov0" title="0">{
        // Get executable path and working directory
        executablePath, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get executable path: %w", err)
        }</span>

        <span class="cov0" title="0">workingDir := args.WorkingDir
        if workingDir == "" </span><span class="cov0" title="0">{
                workingDir = filepath.Dir(executablePath)
        }</span>

        // Convert relative paths to absolute (based on working directory)
        // IMPORTANT: Modify args directly so logger uses absolute paths
        <span class="cov0" title="0">if args.ConfigPath != "" &amp;&amp; !filepath.IsAbs(args.ConfigPath) </span><span class="cov0" title="0">{
                args.ConfigPath = filepath.Join(workingDir, args.ConfigPath)
        }</span>

        <span class="cov0" title="0">if args.LogFile != "" &amp;&amp; !filepath.IsAbs(args.LogFile) </span><span class="cov0" title="0">{
                args.LogFile = filepath.Join(workingDir, args.LogFile)
        }</span>

        // Create logger early for better logging
        <span class="cov0" title="0">appLogger := logger.NewLogger(args)

        // Service configuration
        svcConfig := &amp;service.Config{
                Name:             args.ServiceName,
                DisplayName:      "MCP Server PRTG",
                Description:      "MCP Server for PRTG monitoring data - provides remote access via SSE transport",
                Executable:       executablePath,
                WorkingDirectory: workingDir,
        }

        // Create program
        prg := &amp;program{
                args:      args,
                appLogger: appLogger,
                done:      make(chan bool, 1),
        }

        // Create service
        svc, err := service.New(prg, svcConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create service: %w", err)
        }</span>

        // Get service logger
        <span class="cov0" title="0">svcLogger, err := svc.Logger(nil)
        if err != nil </span><span class="cov0" title="0">{
                appLogger.Warn().Err(err).Msg("Failed to create service logger")
        }</span>

        // Interactive mode (console): run with signal handling
        <span class="cov0" title="0">if service.Interactive() </span><span class="cov0" title="0">{
                appLogger.Info().Msg("Running in interactive/console mode")

                // Start agent directly
                if err := prg.Start(svc); err != nil </span><span class="cov0" title="0">{
                        appLogger.Error().Err(err).Msg("Failed to start agent")
                        return fmt.Errorf("failed to start: %w", err)
                }</span>

                // Setup signal handling for graceful shutdown
                <span class="cov0" title="0">sigChan := make(chan os.Signal, 1)
                signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

                go func() </span><span class="cov0" title="0">{
                        sig := &lt;-sigChan
                        appLogger.Info().Msgf("Received signal: %v", sig)
                        appLogger.Info().Msg("Shutting down gracefully...")
                        if err := prg.Stop(svc); err != nil </span><span class="cov0" title="0">{
                                appLogger.Error().Err(err).Msg("Error stopping service")
                        }</span>
                }()

                // Wait for completion
                <span class="cov0" title="0">&lt;-prg.done
                appLogger.Info().Msg("Agent stopped")
                return nil</span>
        }

        // Service mode: let the service framework handle everything
        <span class="cov0" title="0">if svcLogger != nil </span><span class="cov0" title="0">{
                if err := svcLogger.Info("Starting service"); err != nil </span><span class="cov0" title="0">{
                        appLogger.Warn().Err(err).Msg("Failed to log service start message")
                }</span>
        }

        <span class="cov0" title="0">if err := svc.Run(); err != nil </span><span class="cov0" title="0">{
                if svcLogger != nil </span><span class="cov0" title="0">{
                        if logErr := svcLogger.Error(fmt.Sprintf("Error running service: %v", err)); logErr != nil </span><span class="cov0" title="0">{
                                appLogger.Warn().Err(logErr).Msg("Failed to log service error")
                        }</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("service failed to run: %w", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// createService creates a service instance.
func createService(args *cliArgs.ParsedArgs) (service.Service, error) <span class="cov0" title="0">{
        // Get executable path
        executablePath, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get executable path: %w", err)
        }</span>

        // Determine working directory
        <span class="cov0" title="0">workingDir := args.WorkingDir
        if workingDir == "" </span><span class="cov0" title="0">{
                workingDir = filepath.Dir(executablePath)
        }</span>

        // Convert relative paths to absolute (based on working directory)
        // IMPORTANT: Modify args directly so logger uses absolute paths
        <span class="cov0" title="0">if args.ConfigPath != "" &amp;&amp; !filepath.IsAbs(args.ConfigPath) </span><span class="cov0" title="0">{
                args.ConfigPath = filepath.Join(workingDir, args.ConfigPath)
        }</span>

        <span class="cov0" title="0">if args.LogFile != "" &amp;&amp; !filepath.IsAbs(args.LogFile) </span><span class="cov0" title="0">{
                args.LogFile = filepath.Join(workingDir, args.LogFile)
        }</span>

        // Service arguments
        // Note: Log level is controlled by config file, not CLI flags
        <span class="cov0" title="0">serviceArgs := []string{"run"}
        if args.ConfigPath != "" </span><span class="cov0" title="0">{
                serviceArgs = append(serviceArgs, "--config", args.ConfigPath)
        }</span>
        <span class="cov0" title="0">if args.LogFile != "" </span><span class="cov0" title="0">{
                serviceArgs = append(serviceArgs, "--log-file", args.LogFile)
        }</span>

        // Service configuration
        <span class="cov0" title="0">svcConfig := &amp;service.Config{
                Name:             args.ServiceName,
                DisplayName:      "MCP Server PRTG",
                Description:      "MCP Server for PRTG monitoring data - provides remote access via SSE transport",
                Executable:       executablePath,
                Arguments:        serviceArgs,
                WorkingDirectory: workingDir,
                Option: service.KeyValue{
                        "LogOutput":             true,
                        "User":                  "root",
                        "ServiceName":           args.ServiceName + ".service",
                        "SystemdScript":         true,
                        "Restart":               "always",
                        "RestartSec":            "10",
                        "StartLimitIntervalSec": "0",
                        "StartLimitBurst":       "0",
                },
        }

        // Create logger early (before service starts)
        // args.LogFile is now absolute, so logger will write to correct location
        appLogger := logger.NewLogger(args)

        // Create program
        prg := &amp;program{
                args:      args,
                appLogger: appLogger,
        }

        // Create service
        return service.New(prg, svcConfig)</span>
}

// getServiceStatus returns the service status with detailed information.
func getServiceStatus(args *cliArgs.ParsedArgs) error <span class="cov0" title="0">{
        svc, err := createService(args)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">status, err := svc.Status()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get service status: %w", err)
        }</span>

        <span class="cov0" title="0">var statusText string
        var statusSymbol string
        switch status </span>{
        case service.StatusRunning:<span class="cov0" title="0">
                statusText = "Running"
                statusSymbol = "✅"</span>
        case service.StatusStopped:<span class="cov0" title="0">
                statusText = "Stopped"
                statusSymbol = "⏹️"</span>
        case service.StatusUnknown:<span class="cov0" title="0">
                statusText = "Unknown"
                statusSymbol = "❓"</span>
        default:<span class="cov0" title="0">
                statusText = "Unknown"
                statusSymbol = "❓"</span>
        }

        // Display status header
        <span class="cov0" title="0">fmt.Println("═══════════════════════════════════════════════════════════════")
        fmt.Printf("  MCP Server PRTG - Service Status\n")
        fmt.Println("═══════════════════════════════════════════════════════════════")
        fmt.Println()
        fmt.Printf("%s Service Status:  %s\n", statusSymbol, statusText)
        fmt.Printf("📋 Service Name:    %s\n", args.ServiceName)
        fmt.Println()

        // Display configuration
        fmt.Println("Configuration:")
        fmt.Printf("  Config File:  %s\n", args.ConfigPath)
        fmt.Printf("  Log File:     %s\n", args.LogFile)
        fmt.Printf("  Log Level:    %s\n", args.LogLevel)
        fmt.Println()

        // Try to load config for more details (only if config exists)
        if _, err := os.Stat(args.ConfigPath); err == nil </span><span class="cov0" title="0">{
                // Create a silent logger for status check
                silentLogger := logger.NewSilentLogger()
                config, err := configuration.NewConfiguration(args, silentLogger)
                if err == nil </span><span class="cov0" title="0">{
                        defer config.Shutdown(context.Background())

                        fmt.Println("Server:")
                        fmt.Printf("  Address:      %s\n", config.GetServerAddress())
                        fmt.Printf("  Public URL:   %s\n", config.GetPublicURL())
                        fmt.Printf("  TLS Enabled:  %v\n", config.IsTLSEnabled())
                        if config.IsTLSEnabled() </span><span class="cov0" title="0">{
                                fmt.Printf("  Certificate:  %s\n", config.GetTLSCertFile())
                        }</span>
                        <span class="cov0" title="0">fmt.Println()

                        // Database information
                        fmt.Println("Database:")
                        fmt.Printf("  Host:     %s:%d\n", config.GetDatabaseHost(), config.GetDatabasePort())
                        fmt.Printf("  Database: %s\n", config.GetDatabaseName())
                        fmt.Printf("  User:     %s\n", config.GetDatabaseUser())
                        fmt.Printf("  SSL Mode: %s\n", config.GetDatabaseSSLMode())

                        // Try to test database connection
                        connStr := config.GetDatabaseConnectionString()
                        db, err := database.New(connStr, silentLogger)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("  Status:   ❌ Connection Failed (%v)\n", err)
                        }</span> else<span class="cov0" title="0"> {
                                defer db.Close()
                                fmt.Printf("  Status:   ✅ Connected\n")
                        }</span>
                }
        }

        <span class="cov0" title="0">fmt.Println()
        fmt.Println("═══════════════════════════════════════════════════════════════")
        return nil</span>
}

// cleanupFiles removes configuration files, logs, and certificates during uninstall.
func cleanupFiles(args *cliArgs.ParsedArgs) <span class="cov0" title="0">{
        var filesToRemove []string
        var dirsToRemove []string

        // Get executable directory
        execPath, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Warning: Could not get executable path: %v\n", err)
                return
        }</span>
        <span class="cov0" title="0">workingDir := filepath.Dir(execPath)

        // Configuration file
        configPath := args.ConfigPath
        if configPath == "" </span><span class="cov0" title="0">{
                configPath = filepath.Join(workingDir, "config.yaml")
        }</span>
        <span class="cov0" title="0">if !filepath.IsAbs(configPath) </span><span class="cov0" title="0">{
                configPath = filepath.Join(workingDir, configPath)
        }</span>
        <span class="cov0" title="0">if _, err := os.Stat(configPath); err == nil </span><span class="cov0" title="0">{
                filesToRemove = append(filesToRemove, configPath)
        }</span>

        // Certificate directory
        <span class="cov0" title="0">certsDir := filepath.Join(workingDir, "certs")
        if _, err := os.Stat(certsDir); err == nil </span><span class="cov0" title="0">{
                dirsToRemove = append(dirsToRemove, certsDir)
        }</span>

        // Log directory
        <span class="cov0" title="0">logFile := args.LogFile
        if logFile == "" </span><span class="cov0" title="0">{
                logFile = filepath.Join(workingDir, "logs", "mcp-server-prtg.log")
        }</span>
        <span class="cov0" title="0">if !filepath.IsAbs(logFile) </span><span class="cov0" title="0">{
                logFile = filepath.Join(workingDir, logFile)
        }</span>
        <span class="cov0" title="0">logDir := filepath.Dir(logFile)
        if _, err := os.Stat(logDir); err == nil </span><span class="cov0" title="0">{
                dirsToRemove = append(dirsToRemove, logDir)
        }</span>

        // Remove files
        <span class="cov0" title="0">for _, file := range filesToRemove </span><span class="cov0" title="0">{
                if err := os.Remove(file); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: Could not remove %s: %v\n", file, err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("✅ Removed: %s\n", file)
                }</span>
        }

        // Remove directories
        <span class="cov0" title="0">for _, dir := range dirsToRemove </span><span class="cov0" title="0">{
                if err := os.RemoveAll(dir); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: Could not remove directory %s: %v\n", dir, err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("✅ Removed directory: %s\n", dir)
                }</span>
        }

        <span class="cov0" title="0">if len(filesToRemove) == 0 &amp;&amp; len(dirsToRemove) == 0 </span><span class="cov0" title="0">{
                fmt.Println("✅ No additional files to clean up")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("\n🧹 Cleanup completed - removed %d files and %d directories\n",
                        len(filesToRemove), len(dirsToRemove))
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package agent

import (
        "context"
        "fmt"
        "time"

        mcpserver "github.com/mark3labs/mcp-go/server"
        "github.com/matthieu/mcp-server-prtg/internal/cliArgs"
        "github.com/matthieu/mcp-server-prtg/internal/database"
        "github.com/matthieu/mcp-server-prtg/internal/handlers"
        "github.com/matthieu/mcp-server-prtg/internal/server"
        "github.com/matthieu/mcp-server-prtg/internal/services/configuration"
        "github.com/matthieu/mcp-server-prtg/internal/services/logger"
)

// Agent represents the main application orchestrator.
type Agent struct {
        config     *configuration.Configuration
        logger     *logger.Logger
        db         *database.DB
        sseServer  *server.SSEServerV2
        args       *cliArgs.ParsedArgs
        shutdownCh chan struct{} // Channel to signal shutdown
}

// NewAgent creates a new agent instance.
func NewAgent(args *cliArgs.ParsedArgs) (*Agent, error) <span class="cov0" title="0">{
        // Initialize logger
        baseLogger := logger.NewLogger(args)

        moduleLogger := logger.NewModuleLogger(baseLogger, "agent")
        moduleLogger.Info().Msg("Initializing MCP Server PRTG Agent")

        // Load or create configuration
        config, err := configuration.NewConfiguration(args, baseLogger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize configuration: %w", err)
        }</span>

        <span class="cov0" title="0">moduleLogger.Info().
                Str("config_path", args.ConfigPath).
                Str("api_key_preview", maskKey(config.GetAPIKey())).
                Msg("Configuration loaded")

        // Initialize database (optional - server can start without database)
        dbLogger := logger.NewModuleLogger(baseLogger, logger.ModuleDatabase)
        connStr := config.GetDatabaseConnectionString()

        // Log connection attempt (with masked password)
        moduleLogger.Debug().
                Str("host", config.GetDatabaseHost()).
                Int("port", config.GetDatabasePort()).
                Str("database", config.GetDatabaseName()).
                Str("user", config.GetDatabaseUser()).
                Str("sslmode", config.GetDatabaseSSLMode()).
                Msg("Attempting database connection")

        db, err := database.New(connStr, dbLogger.Logger)
        if err != nil </span><span class="cov0" title="0">{
                moduleLogger.Warn().
                        Err(err).
                        Str("sslmode", config.GetDatabaseSSLMode()).
                        Msg("Failed to initialize database - server will start but tools will not work")
                db = nil
        }</span> else<span class="cov0" title="0"> {
                moduleLogger.Info().Msg("Database connection established")
        }</span>

        // Create MCP server
        <span class="cov0" title="0">mcpServer := mcpserver.NewMCPServer(
                "prtg-server",
                "1.0.0",
        )

        // Register MCP tools
        toolHandler := handlers.NewToolHandler(db, baseLogger)
        toolHandler.RegisterTools(mcpServer)

        moduleLogger.Info().
                Int("tools_count", 6).
                Msg("MCP tools registered")

        // Create SSE server (v2 with proxy architecture)
        sseServer := server.NewSSEServerV2(mcpServer, db, config, baseLogger)

        return &amp;Agent{
                config:     config,
                logger:     baseLogger,
                db:         db,
                sseServer:  sseServer,
                args:       args,
                shutdownCh: make(chan struct{}),
        }, nil</span>
}

// Start starts the agent.
func (a *Agent) Start() error <span class="cov0" title="0">{
        moduleLogger := logger.NewModuleLogger(a.logger, "agent")
        moduleLogger.Info().Msg("Starting agent")

        // Start SSE server
        ctx := context.Background()
        if err := a.sseServer.Start(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start SSE server: %w", err)
        }</span>

        // Wait for shutdown signal (server runs in goroutine)
        <span class="cov0" title="0">&lt;-a.shutdownCh
        moduleLogger.Info().Msg("Shutdown signal received, agent stopping")

        return nil</span>
}

// Shutdown gracefully shuts down the agent.
func (a *Agent) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        moduleLogger := logger.NewModuleLogger(a.logger, "agent")
        moduleLogger.Info().Msg("Shutting down agent")

        // Signal shutdown to Start() (close channel only once)
        select </span>{
        case &lt;-a.shutdownCh:<span class="cov0" title="0"></span>
                // Already closed
        default:<span class="cov0" title="0">
                close(a.shutdownCh)</span>
        }

        // Create shutdown context with timeout
        <span class="cov0" title="0">shutdownCtx, cancel := context.WithTimeout(ctx, 10*time.Second)
        defer cancel()

        // Shutdown SSE server
        if a.sseServer != nil </span><span class="cov0" title="0">{
                if err := a.sseServer.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                        moduleLogger.Error().Err(err).Msg("Error shutting down SSE server")
                }</span>
        }

        // Close database
        <span class="cov0" title="0">if a.db != nil </span><span class="cov0" title="0">{
                if err := a.db.Close(); err != nil </span><span class="cov0" title="0">{
                        moduleLogger.Error().Err(err).Msg("Error closing database")
                }</span>
        }

        // Shutdown configuration watcher
        <span class="cov0" title="0">if a.config != nil </span><span class="cov0" title="0">{
                if err := a.config.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                        moduleLogger.Error().Err(err).Msg("Error shutting down configuration")
                }</span>
        }

        <span class="cov0" title="0">moduleLogger.Info().Msg("Agent shut down successfully")

        return nil</span>
}

// maskKey masks an API key for logging.
func maskKey(key string) string <span class="cov0" title="0">{
        if len(key) &lt;= 8 </span><span class="cov0" title="0">{
                return "***"
        }</span>

        <span class="cov0" title="0">return key[:4] + "..." + key[len(key)-4:]</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package cliArgs

import "github.com/alexflint/go-arg"

// ParsedArgs contains all command-line arguments for the MCP Server.
type ParsedArgs struct {
        // Command to execute
        Command string `arg:"positional" help:"Command to execute (run, install, start, stop, uninstall, config)"`

        // Configuration
        ConfigPath string `arg:"--config,-c" help:"Path to configuration file" default:"./config.yaml"`

        // Server settings
        Port        int    `arg:"--port,-p" help:"Server port" default:"8443"`
        BindAddress string `arg:"--bind" help:"Bind address" default:"0.0.0.0"`
        EnableHTTPS bool   `arg:"--https" help:"Enable HTTPS" default:"true"`
        CertFile    string `arg:"--cert" help:"Path to TLS certificate file"`
        KeyFile     string `arg:"--key" help:"Path to TLS private key file"`
        AuthKey     string `arg:"--api-key" help:"API key for authentication"`

        // Database settings
        DBHost     string `arg:"--db-host" help:"Database host" env:"PRTG_DB_HOST"`
        DBPort     int    `arg:"--db-port" help:"Database port" env:"PRTG_DB_PORT"`
        DBName     string `arg:"--db-name" help:"Database name" env:"PRTG_DB_NAME"`
        DBUser     string `arg:"--db-user" help:"Database user" env:"PRTG_DB_USER"`
        DBPassword string `arg:"--db-password" help:"Database password" env:"PRTG_DB_PASSWORD"`
        DBSSLMode  string `arg:"--db-sslmode" help:"Database SSL mode" env:"PRTG_DB_SSLMODE"`

        // Logging
        Verbose      bool     `arg:"--verbose,-v" help:"Enable verbose logging (debug level)"`
        LogLevel     string   `arg:"--log-level" help:"Log level (debug, info, warn, error)" default:"info"`
        LogFile      string   `arg:"--log-file" help:"Log file path" default:"./logs/mcp-server-prtg.log"`
        DebugModules []string `arg:"--debug-modules" help:"Comma-separated list of modules to debug"`

        // Service
        ServiceName string `arg:"--service-name" help:"Service name" default:"mcp-server-prtg"`
        WorkingDir  string `arg:"--working-dir" help:"Working directory for service"`
}

// Parse parses command-line arguments.
func Parse() *ParsedArgs <span class="cov0" title="0">{
        return ParseWithVersion("mcp-server-prtg v1.0.0 (dev)")
}</span>

// ParseWithVersion parses command-line arguments with a custom version string.
func ParseWithVersion(version string) *ParsedArgs <span class="cov0" title="0">{
        args := &amp;argsWithVersion{
                version: version,
        }
        arg.MustParse(args)
        return &amp;args.ParsedArgs
}</span>

// argsWithVersion wraps ParsedArgs with a version string.
type argsWithVersion struct {
        ParsedArgs
        version string
}

// Description returns the program description.
func (a *argsWithVersion) Description() string <span class="cov0" title="0">{
        return "MCP Server for PRTG monitoring data - provides remote access to PRTG PostgreSQL database via MCP protocol over SSE transport"
}</span>

// Version returns the version information.
func (a *argsWithVersion) Version() string <span class="cov0" title="0">{
        return a.version
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"

        "gopkg.in/yaml.v3"
)

// Config holds the application configuration.
type Config struct {
        Database DatabaseConfig `yaml:"database"`
        Log      LogConfig      `yaml:"log"`
}

// DatabaseConfig holds database connection settings.
type DatabaseConfig struct {
        Host     string `yaml:"host"`
        Port     int    `yaml:"port"`
        Name     string `yaml:"name"`
        User     string `yaml:"user"`
        Password string `yaml:"password"`
        SSLMode  string `yaml:"sslmode"`
}

// LogConfig holds logging settings.
type LogConfig struct {
        Level string `yaml:"level"`
}

// Load reads configuration from environment variables and optional YAML file.
func Load(configPath string) (*Config, error) <span class="cov0" title="0">{
        cfg := &amp;Config{
                Database: DatabaseConfig{
                        Host:     getEnv("PRTG_DB_HOST", "localhost"),
                        Port:     getEnvInt("PRTG_DB_PORT", 5432),
                        Name:     getEnv("PRTG_DB_NAME", "prtg_data_exporter"),
                        User:     getEnv("PRTG_DB_USER", "prtg_reader"),
                        Password: getEnv("PRTG_DB_PASSWORD", ""),
                        SSLMode:  getEnv("PRTG_DB_SSLMODE", "disable"),
                },
                Log: LogConfig{
                        Level: getEnv("LOG_LEVEL", "info"),
                },
        }

        // Override with YAML file if provided
        if configPath != "" </span><span class="cov0" title="0">{
                if err := loadYAMLConfig(configPath, cfg); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to load config file: %w", err)
                }</span>
        }

        // Validate required fields
        <span class="cov0" title="0">if cfg.Database.Password == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("database password is required (set PRTG_DB_PASSWORD)")
        }</span>

        <span class="cov0" title="0">return cfg, nil</span>
}

// loadYAMLConfig loads configuration from a YAML file.
func loadYAMLConfig(path string, cfg *Config) error <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return yaml.Unmarshal(data, cfg)</span>
}

// getEnv retrieves an environment variable or returns a default value.
func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>

        <span class="cov0" title="0">return defaultValue</span>
}

// getEnvInt retrieves an integer environment variable or returns a default value.
func getEnvInt(key string, defaultValue int) int <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if intVal, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        return intVal
                }</span>
        }

        <span class="cov0" title="0">return defaultValue</span>
}

// ConnectionString builds a PostgreSQL connection string.
func (d *DatabaseConfig) ConnectionString() string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "host=%s port=%d dbname=%s user=%s password=%s sslmode=%s",
                d.Host, d.Port, d.Name, d.User, d.Password, d.SSLMode,
        )
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "github.com/rs/zerolog"

        // PostgreSQL driver.
        _ "github.com/lib/pq"
)

// DB wraps the database connection and provides query methods
type DB struct {
        conn   *sql.DB
        logger *zerolog.Logger
}

// New creates a new database connection with proper pool settings
func New(connStr string, logger *zerolog.Logger) (*DB, error) <span class="cov0" title="0">{
        conn, err := sql.Open("postgres", connStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        // Configure connection pool
        <span class="cov0" title="0">conn.SetMaxOpenConns(25)
        conn.SetMaxIdleConns(5)
        conn.SetConnMaxLifetime(5 * time.Minute)

        // Test connection
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        if err := conn.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                conn.Close()
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Info().Msg("database connection established")

        return &amp;DB{
                conn:   conn,
                logger: logger,
        }, nil</span>
}

// Close closes the database connection
func (db *DB) Close() error <span class="cov0" title="0">{
        if db.conn != nil </span><span class="cov0" title="0">{
                return db.conn.Close()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Conn returns the underlying database connection
func (db *DB) Conn() *sql.DB <span class="cov0" title="0">{
        return db.conn
}</span>

// Query executes a query using the provided context
// IMPORTANT: The context must remain valid while scanning rows.
// The caller is responsible for context lifetime management.
func (db *DB) Query(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) <span class="cov0" title="0">{
        db.logger.Debug().
                Str("query", query).
                Interface("args", args).
                Msg("executing query")

        return db.conn.QueryContext(ctx, query, args...)
}</span>

// QueryRow executes a query expected to return at most one row
func (db *DB) QueryRow(ctx context.Context, query string, args ...interface{}) *sql.Row <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, 30*time.Second)
        defer cancel()

        db.logger.Debug().
                Str("query", query).
                Interface("args", args).
                Msg("executing query row")

        return db.conn.QueryRowContext(ctx, query, args...)
}</span>

// Exec executes a query that doesn't return rows
func (db *DB) Exec(ctx context.Context, query string, args ...interface{}) (sql.Result, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, 30*time.Second)
        defer cancel()

        db.logger.Debug().
                Str("query", query).
                Interface("args", args).
                Msg("executing statement")

        return db.conn.ExecContext(ctx, query, args...)
}</span>

// Health checks the database connection health
func (db *DB) Health(ctx context.Context) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, 2*time.Second)
        defer cancel()

        if err := db.conn.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("database ping failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"
        "strings"
        "time"

        "github.com/matthieu/mcp-server-prtg/internal/types"
)

// GetSensors retrieves sensors with optional filters
func (db *DB) GetSensors(ctx context.Context, deviceName, sensorName string, status *int, tags string, limit int) ([]types.Sensor, error) <span class="cov0" title="0">{
        // Simplified query without tags subquery for performance
        query := `
                SELECT
                        s.id,
                        s.prtg_server_address_id,
                        s.name,
                        s.sensor_type,
                        s.prtg_device_id,
                        d.name AS device_name,
                        s.scanning_interval_seconds,
                        s.status,
                        s.last_check_utc,
                        s.last_up_utc,
                        s.last_down_utc,
                        s.priority,
                        s.message,
                        s.uptime_since_seconds,
                        s.downtime_since_seconds,
                        sp.path AS full_path,
                        '' AS tags
                FROM prtg_sensor s
                INNER JOIN prtg_device d ON s.prtg_device_id = d.id
                        AND s.prtg_server_address_id = d.prtg_server_address_id
                INNER JOIN prtg_sensor_path sp ON s.id = sp.sensor_id
                        AND s.prtg_server_address_id = sp.prtg_server_address_id
                WHERE 1=1
        `

        args := []interface{}{}
        argPos := 1

        // Add filters
        if deviceName != "" </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" AND d.name ILIKE $%d", argPos)
                args = append(args, "%"+deviceName+"%")
                argPos++
        }</span>

        <span class="cov0" title="0">if sensorName != "" </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" AND s.name ILIKE $%d", argPos)

                args = append(args, "%"+sensorName+"%")
                argPos++
        }</span>

        <span class="cov0" title="0">if status != nil </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" AND s.status = $%d", argPos)

                args = append(args, *status)
                argPos++
        }</span>

        // Tags filter temporarily disabled for performance
        // TODO: Re-enable with proper indexing
        <span class="cov0" title="0">_ = tags

        query += " ORDER BY s.name"

        if limit &gt; 0 </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" LIMIT $%d", argPos)

                args = append(args, limit)
        }</span>

        <span class="cov0" title="0">db.logger.Debug().
                Str("query", query).
                Interface("args", args).
                Msg("executing GetSensors query")

        startTime := time.Now()
        rows, err := db.Query(ctx, query, args...)
        queryDuration := time.Since(startTime)

        if err != nil </span><span class="cov0" title="0">{
                db.logger.Error().
                        Err(err).
                        Dur("duration_ms", queryDuration).
                        Str("query", query).
                        Msg("query failed")
                return nil, fmt.Errorf("query failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        db.logger.Info().Dur("query_duration_ms", queryDuration).Msg("query executed, scanning rows")

        scanStart := time.Now()
        sensors, err := scanSensors(rows)
        scanDuration := time.Since(scanStart)

        if err != nil </span><span class="cov0" title="0">{
                db.logger.Error().Err(err).Dur("scan_duration_ms", scanDuration).Msg("scanSensors failed")
                return nil, err
        }</span>

        <span class="cov0" title="0">db.logger.Info().
                Int("sensors_count", len(sensors)).
                Dur("query_ms", queryDuration).
                Dur("scan_ms", scanDuration).
                Dur("total_ms", time.Since(startTime)).
                Msg("GetSensors completed")
        return sensors, nil</span>
}

// GetSensorByID retrieves a single sensor by ID
func (db *DB) GetSensorByID(ctx context.Context, sensorID int) (*types.Sensor, error) <span class="cov0" title="0">{
        query := `
                SELECT
                        s.id,
                        s.prtg_server_address_id,
                        s.name,
                        s.sensor_type,
                        s.prtg_device_id,
                        d.name AS device_name,
                        s.scanning_interval_seconds,
                        s.status,
                        s.last_check_utc,
                        s.last_up_utc,
                        s.last_down_utc,
                        s.priority,
                        s.message,
                        s.uptime_since_seconds,
                        s.downtime_since_seconds,
                        sp.path AS full_path,
                        COALESCE(
                                (SELECT string_agg(t.name, ',')
                                 FROM prtg_sensor_tag st
                                 JOIN prtg_tag t ON st.prtg_tag_id = t.id
                                 WHERE st.prtg_sensor_id = s.id
                                 AND st.prtg_server_address_id = s.prtg_server_address_id),
                                ''
                        ) AS tags
                FROM prtg_sensor s
                INNER JOIN prtg_device d ON s.prtg_device_id = d.id
                        AND s.prtg_server_address_id = d.prtg_server_address_id
                INNER JOIN prtg_sensor_path sp ON s.id = sp.sensor_id
                        AND s.prtg_server_address_id = sp.prtg_server_address_id
                WHERE s.id = $1
        `

        var sensor types.Sensor

        var lastCheckUTC, lastDownUTC sql.NullTime

        var uptimeSecs, downtimeSecs sql.NullFloat64

        var message, tags sql.NullString

        err := db.QueryRow(ctx, query, sensorID).Scan(
                &amp;sensor.ID,
                &amp;sensor.ServerID,
                &amp;sensor.Name,
                &amp;sensor.SensorType,
                &amp;sensor.DeviceID,
                &amp;sensor.DeviceName,
                &amp;sensor.ScanningIntervalSecs,
                &amp;sensor.Status,
                &amp;lastCheckUTC,
                &amp;sensor.LastUpUTC,
                &amp;lastDownUTC,
                &amp;sensor.Priority,
                &amp;message,
                &amp;uptimeSecs,
                &amp;downtimeSecs,
                &amp;sensor.FullPath,
                &amp;tags,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("sensor not found")
                }</span>

                <span class="cov0" title="0">return nil, fmt.Errorf("query failed: %w", err)</span>
        }

        // Handle nullable fields
        <span class="cov0" title="0">if lastCheckUTC.Valid </span><span class="cov0" title="0">{
                sensor.LastCheckUTC = &amp;lastCheckUTC.Time
        }</span>

        <span class="cov0" title="0">if lastDownUTC.Valid </span><span class="cov0" title="0">{
                sensor.LastDownUTC = &amp;lastDownUTC.Time
        }</span>

        <span class="cov0" title="0">if uptimeSecs.Valid </span><span class="cov0" title="0">{
                sensor.UptimeSinceSecs = &amp;uptimeSecs.Float64
        }</span>

        <span class="cov0" title="0">if downtimeSecs.Valid </span><span class="cov0" title="0">{
                sensor.DowntimeSinceSecs = &amp;downtimeSecs.Float64
        }</span>

        <span class="cov0" title="0">if message.Valid </span><span class="cov0" title="0">{
                sensor.Message = message.String
        }</span>

        <span class="cov0" title="0">if tags.Valid </span><span class="cov0" title="0">{
                sensor.Tags = tags.String
        }</span>

        <span class="cov0" title="0">sensor.StatusText = types.GetStatusText(sensor.Status)

        return &amp;sensor, nil</span>
}

// GetAlerts retrieves sensors in alert state (non-UP status)
func (db *DB) GetAlerts(ctx context.Context, hours int, statusFilter *int, deviceName string) ([]types.Sensor, error) <span class="cov0" title="0">{
        query := `
                SELECT
                        s.id,
                        s.prtg_server_address_id,
                        s.name,
                        s.sensor_type,
                        s.prtg_device_id,
                        d.name AS device_name,
                        s.scanning_interval_seconds,
                        s.status,
                        s.last_check_utc,
                        s.last_up_utc,
                        s.last_down_utc,
                        s.priority,
                        s.message,
                        s.uptime_since_seconds,
                        s.downtime_since_seconds,
                        sp.path AS full_path,
                        COALESCE(
                                (SELECT string_agg(t.name, ',')
                                 FROM prtg_sensor_tag st
                                 JOIN prtg_tag t ON st.prtg_tag_id = t.id
                                 WHERE st.prtg_sensor_id = s.id
                                 AND st.prtg_server_address_id = s.prtg_server_address_id),
                                ''
                        ) AS tags
                FROM prtg_sensor s
                INNER JOIN prtg_device d ON s.prtg_device_id = d.id
                        AND s.prtg_server_address_id = d.prtg_server_address_id
                INNER JOIN prtg_sensor_path sp ON s.id = sp.sensor_id
                        AND s.prtg_server_address_id = sp.prtg_server_address_id
                WHERE s.status != $1
        `

        args := []interface{}{types.StatusUp}
        argPos := 2

        if hours &gt; 0 </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" AND s.last_check_utc &gt;= NOW() - ($%d || ' hours')::interval", argPos)

                args = append(args, hours)
                argPos++
        }</span>

        <span class="cov0" title="0">if statusFilter != nil </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" AND s.status = $%d", argPos)

                args = append(args, *statusFilter)
                argPos++
        }</span>

        <span class="cov0" title="0">if deviceName != "" </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" AND d.name ILIKE $%d", argPos)

                args = append(args, "%"+deviceName+"%")
        }</span>

        <span class="cov0" title="0">query += " ORDER BY s.priority DESC, s.status, s.name LIMIT 100"

        rows, err := db.Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return scanSensors(rows)</span>
}

// GetDeviceOverview retrieves a device with all its sensors
func (db *DB) GetDeviceOverview(ctx context.Context, deviceName string) (*types.DeviceOverview, error) <span class="cov0" title="0">{
        // Get device info
        deviceQuery := `
                SELECT
                        d.id,
                        d.prtg_server_address_id,
                        d.name,
                        d.host,
                        d.prtg_group_id,
                        g.name AS group_name,
                        dp.path AS full_path,
                        d.tree_depth,
                        COALESCE(
                                (SELECT COUNT(*) FROM prtg_sensor s
                                 WHERE s.prtg_device_id = d.id
                                 AND s.prtg_server_address_id = d.prtg_server_address_id),
                                0
                        ) AS sensor_count
                FROM prtg_device d
                INNER JOIN prtg_group g ON d.prtg_group_id = g.id
                        AND d.prtg_server_address_id = g.prtg_server_address_id
                INNER JOIN prtg_device_path dp ON d.id = dp.device_id
                        AND d.prtg_server_address_id = dp.prtg_server_address_id
                WHERE d.name ILIKE $1
                LIMIT 1
        `

        var device types.Device
        err := db.QueryRow(ctx, deviceQuery, "%"+deviceName+"%").Scan(
                &amp;device.ID,
                &amp;device.ServerID,
                &amp;device.Name,
                &amp;device.Host,
                &amp;device.GroupID,
                &amp;device.GroupName,
                &amp;device.FullPath,
                &amp;device.TreeDepth,
                &amp;device.SensorCount,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("device not found")
                }</span>

                <span class="cov0" title="0">return nil, fmt.Errorf("query failed: %w", err)</span>
        }

        // Get all sensors for this device
        <span class="cov0" title="0">sensorsQuery := `
                SELECT
                        s.id,
                        s.prtg_server_address_id,
                        s.name,
                        s.sensor_type,
                        s.prtg_device_id,
                        $2 AS device_name,
                        s.scanning_interval_seconds,
                        s.status,
                        s.last_check_utc,
                        s.last_up_utc,
                        s.last_down_utc,
                        s.priority,
                        s.message,
                        s.uptime_since_seconds,
                        s.downtime_since_seconds,
                        sp.path AS full_path,
                        COALESCE(
                                (SELECT string_agg(t.name, ',')
                                 FROM prtg_sensor_tag st
                                 JOIN prtg_tag t ON st.prtg_tag_id = t.id
                                 WHERE st.prtg_sensor_id = s.id
                                 AND st.prtg_server_address_id = s.prtg_server_address_id),
                                ''
                        ) AS tags
                FROM prtg_sensor s
                INNER JOIN prtg_sensor_path sp ON s.id = sp.sensor_id
                        AND s.prtg_server_address_id = sp.prtg_server_address_id
                WHERE s.prtg_device_id = $1
                AND s.prtg_server_address_id = $3
                ORDER BY s.status, s.name
        `

        rows, err := db.Query(ctx, sensorsQuery, device.ID, device.Name, device.ServerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get sensors: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        sensors, err := scanSensors(rows)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Calculate statistics
        <span class="cov0" title="0">upCount := 0
        downCount := 0
        warnCount := 0

        for i := range sensors </span><span class="cov0" title="0">{
                switch sensors[i].Status </span>{
                case types.StatusUp:<span class="cov0" title="0">
                        upCount++</span>
                case types.StatusDown:<span class="cov0" title="0">
                        downCount++</span>
                case types.StatusWarning:<span class="cov0" title="0">
                        warnCount++</span>
                }
        }

        <span class="cov0" title="0">return &amp;types.DeviceOverview{
                Device:       device,
                Sensors:      sensors,
                TotalSensors: len(sensors),
                UpSensors:    upCount,
                DownSensors:  downCount,
                WarnSensors:  warnCount,
        }, nil</span>
}

// GetTopSensors retrieves top sensors by various metrics
func (db *DB) GetTopSensors(ctx context.Context, metric, sensorType string, limit, _ int) ([]types.Sensor, error) <span class="cov0" title="0">{
        query := `
                SELECT
                        s.id,
                        s.prtg_server_address_id,
                        s.name,
                        s.sensor_type,
                        s.prtg_device_id,
                        d.name AS device_name,
                        s.scanning_interval_seconds,
                        s.status,
                        s.last_check_utc,
                        s.last_up_utc,
                        s.last_down_utc,
                        s.priority,
                        s.message,
                        s.uptime_since_seconds,
                        s.downtime_since_seconds,
                        sp.path AS full_path,
                        COALESCE(
                                (SELECT string_agg(t.name, ',')
                                 FROM prtg_sensor_tag st
                                 JOIN prtg_tag t ON st.prtg_tag_id = t.id
                                 WHERE st.prtg_sensor_id = s.id
                                 AND st.prtg_server_address_id = s.prtg_server_address_id),
                                ''
                        ) AS tags
                FROM prtg_sensor s
                INNER JOIN prtg_device d ON s.prtg_device_id = d.id
                        AND s.prtg_server_address_id = d.prtg_server_address_id
                INNER JOIN prtg_sensor_path sp ON s.id = sp.sensor_id
                        AND s.prtg_server_address_id = sp.prtg_server_address_id
                WHERE 1=1
        `

        args := []interface{}{}
        argPos := 1

        if sensorType != "" </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" AND s.sensor_type ILIKE $%d", argPos)

                args = append(args, "%"+sensorType+"%")
                argPos++
        }</span>

        // Add ordering based on metric
        <span class="cov0" title="0">switch metric </span>{
        case "downtime":<span class="cov0" title="0">
                query += " ORDER BY s.downtime_since_seconds DESC NULLS LAST"</span>
        case "alerts":<span class="cov0" title="0">
                // Order by non-UP status, then by priority
                query += fmt.Sprintf(" AND s.status != $%d ORDER BY s.priority DESC, s.status", argPos)
                args = append(args, types.StatusUp)
                argPos++</span>
        default:<span class="cov0" title="0"> // "uptime" or default
                query += " ORDER BY s.uptime_since_seconds DESC NULLS LAST"</span>
        }

        <span class="cov0" title="0">if limit &gt; 0 </span><span class="cov0" title="0">{
                query += fmt.Sprintf(" LIMIT $%d", argPos)

                args = append(args, limit)
        }</span>

        <span class="cov0" title="0">rows, err := db.Query(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return scanSensors(rows)</span>
}

// ExecuteCustomQuery executes a custom SQL query (SELECT only)
// WARNING: This function accepts raw SQL and should be used with extreme caution.
// It is recommended to disable this in production environments.
func (db *DB) ExecuteCustomQuery(ctx context.Context, query string, limit int) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        // Security: Validate query is SELECT only
        queryUpper := strings.ToUpper(strings.TrimSpace(query))
        if !strings.HasPrefix(queryUpper, "SELECT") </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("only SELECT queries are allowed")
        }</span>

        // Check for dangerous keywords (including comments to prevent bypass)
        <span class="cov0" title="0">dangerous := []string{"DROP", "DELETE", "UPDATE", "INSERT", "ALTER", "CREATE", "TRUNCATE", "EXEC", "EXECUTE", "/*", "--", ";"}
        for _, keyword := range dangerous </span><span class="cov0" title="0">{
                if strings.Contains(queryUpper, keyword) || strings.Contains(query, keyword) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("query contains forbidden keyword: %s", keyword)
                }</span>
        }

        // Enforce maximum limit
        <span class="cov0" title="0">maxLimit := 1000

        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">if limit &gt; maxLimit </span><span class="cov0" title="0">{
                limit = maxLimit
        }</span>

        // Add limit if not present using parameterized query
        <span class="cov0" title="0">if !strings.Contains(queryUpper, "LIMIT") </span><span class="cov0" title="0">{
                query += " LIMIT $1"

                rows, err := db.conn.QueryContext(ctx, query, limit)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("query failed: %w", err)
                }</span>
                <span class="cov0" title="0">defer rows.Close()

                return scanGenericResults(rows)</span>
        }

        <span class="cov0" title="0">rows, err := db.conn.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return scanGenericResults(rows)</span>
}

// scanGenericResults scans generic SQL query results into maps
func scanGenericResults(rows *sql.Rows) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        // Get column names
        columns, err := rows.Columns()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get columns: %w", err)
        }</span>

        <span class="cov0" title="0">results := []map[string]interface{}{}

        for rows.Next() </span><span class="cov0" title="0">{
                // Create a slice of interface{}'s to represent each column
                values := make([]interface{}, len(columns))
                valuePtrs := make([]interface{}, len(columns))

                for i := range values </span><span class="cov0" title="0">{
                        valuePtrs[i] = &amp;values[i]
                }</span>

                <span class="cov0" title="0">if err := rows.Scan(valuePtrs...); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scan failed: %w", err)
                }</span>

                // Create map for this row
                <span class="cov0" title="0">row := make(map[string]interface{})
                for i, col := range columns </span><span class="cov0" title="0">{
                        row[col] = values[i]
                }</span>
                <span class="cov0" title="0">results = append(results, row)</span>
        }

        <span class="cov0" title="0">return results, rows.Err()</span>
}

// scanSensors is a helper function to scan sensor rows
func scanSensors(rows *sql.Rows) ([]types.Sensor, error) <span class="cov0" title="0">{
        sensors := []types.Sensor{}

        for rows.Next() </span><span class="cov0" title="0">{
                var sensor types.Sensor

                var lastCheckUTC, lastDownUTC sql.NullTime

                var uptimeSecs, downtimeSecs sql.NullFloat64

                var message, tags sql.NullString

                err := rows.Scan(
                        &amp;sensor.ID,
                        &amp;sensor.ServerID,
                        &amp;sensor.Name,
                        &amp;sensor.SensorType,
                        &amp;sensor.DeviceID,
                        &amp;sensor.DeviceName,
                        &amp;sensor.ScanningIntervalSecs,
                        &amp;sensor.Status,
                        &amp;lastCheckUTC,
                        &amp;sensor.LastUpUTC,
                        &amp;lastDownUTC,
                        &amp;sensor.Priority,
                        &amp;message,
                        &amp;uptimeSecs,
                        &amp;downtimeSecs,
                        &amp;sensor.FullPath,
                        &amp;tags,
                )

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scan failed: %w", err)
                }</span>

                // Handle nullable fields
                <span class="cov0" title="0">if lastCheckUTC.Valid </span><span class="cov0" title="0">{
                        sensor.LastCheckUTC = &amp;lastCheckUTC.Time
                }</span>

                <span class="cov0" title="0">if lastDownUTC.Valid </span><span class="cov0" title="0">{
                        sensor.LastDownUTC = &amp;lastDownUTC.Time
                }</span>

                <span class="cov0" title="0">if uptimeSecs.Valid </span><span class="cov0" title="0">{
                        sensor.UptimeSinceSecs = &amp;uptimeSecs.Float64
                }</span>

                <span class="cov0" title="0">if downtimeSecs.Valid </span><span class="cov0" title="0">{
                        sensor.DowntimeSinceSecs = &amp;downtimeSecs.Float64
                }</span>

                <span class="cov0" title="0">if message.Valid </span><span class="cov0" title="0">{
                        sensor.Message = message.String
                }</span>

                <span class="cov0" title="0">if tags.Valid </span><span class="cov0" title="0">{
                        sensor.Tags = tags.String
                }</span>

                <span class="cov0" title="0">sensor.StatusText = types.GetStatusText(sensor.Status)

                sensors = append(sensors, sensor)</span>
        }

        <span class="cov0" title="0">return sensors, rows.Err()</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handlers

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/mark3labs/mcp-go/mcp"
        "github.com/mark3labs/mcp-go/server"
        "github.com/matthieu/mcp-server-prtg/internal/database"
        "github.com/rs/zerolog"
)

// ToolHandler handles MCP tool requests
type ToolHandler struct {
        db     *database.DB
        logger *zerolog.Logger
}

// NewToolHandler creates a new tool handler
func NewToolHandler(db *database.DB, logger *zerolog.Logger) *ToolHandler <span class="cov0" title="0">{
        return &amp;ToolHandler{
                db:     db,
                logger: logger,
        }
}</span>

// RegisterTools registers all available tools with the MCP server
func (h *ToolHandler) RegisterTools(s *server.MCPServer) <span class="cov0" title="0">{
        // Tool 1: prtg_get_sensors
        s.AddTool(mcp.Tool{
                Name: "prtg_get_sensors",
                Description: "Retrieve PRTG sensors with optional filters (device name, sensor name, status, tags). " +
                        "Returns current sensor status and metadata.",
                InputSchema: mcp.ToolInputSchema{
                        Type: "object",
                        Properties: map[string]interface{}{
                                "device_name": map[string]string{
                                        "type":        "string",
                                        "description": "Filter by device name (partial match, case-insensitive)",
                                },
                                "sensor_name": map[string]string{
                                        "type":        "string",
                                        "description": "Filter by sensor name (partial match, case-insensitive)",
                                },
                                "status": map[string]interface{}{
                                        "type":        "integer",
                                        "description": "Filter by status (3=Up, 4=Warning, 5=Down, 7=Paused)",
                                },
                                "tags": map[string]string{
                                        "type":        "string",
                                        "description": "Filter by tag name (partial match)",
                                },
                                "limit": map[string]interface{}{
                                        "type":        "integer",
                                        "description": "Maximum number of results (default: 50)",
                                        "default":     50,
                                },
                        },
                },
        }, h.handleGetSensors)

        // Tool 2: prtg_get_sensor_status
        s.AddTool(mcp.Tool{
                Name: "prtg_get_sensor_status",
                Description: "Get detailed current status of a specific sensor by ID. " +
                        "Returns current values, uptime, downtime, and status information.",
                InputSchema: mcp.ToolInputSchema{
                        Type: "object",
                        Properties: map[string]interface{}{
                                "sensor_id": map[string]interface{}{
                                        "type":        "integer",
                                        "description": "The sensor ID to query",
                                },
                        },
                        Required: []string{"sensor_id"},
                },
        }, h.handleGetSensorStatus)

        // Tool 3: prtg_get_alerts
        s.AddTool(mcp.Tool{
                Name:        "prtg_get_alerts",
                Description: "Retrieve sensors in alert state (not Up). Returns sensors with warnings, errors, or down status.",
                InputSchema: mcp.ToolInputSchema{
                        Type: "object",
                        Properties: map[string]interface{}{
                                "hours": map[string]interface{}{
                                        "type":        "integer",
                                        "description": "Only include alerts from the last N hours (0 = all)",
                                        "default":     24,
                                },
                                "status": map[string]interface{}{
                                        "type":        "integer",
                                        "description": "Filter by specific status (4=Warning, 5=Down)",
                                },
                                "device_name": map[string]string{
                                        "type":        "string",
                                        "description": "Filter by device name",
                                },
                        },
                },
        }, h.handleGetAlerts)

        // Tool 4: prtg_device_overview
        s.AddTool(mcp.Tool{
                Name:        "prtg_device_overview",
                Description: "Get a complete overview of a device including all its sensors and statistics (up/down/warning counts).",
                InputSchema: mcp.ToolInputSchema{
                        Type: "object",
                        Properties: map[string]interface{}{
                                "device_name": map[string]string{
                                        "type":        "string",
                                        "description": "Device name to query (partial match)",
                                },
                        },
                        Required: []string{"device_name"},
                },
        }, h.handleDeviceOverview)

        // Tool 5: prtg_top_sensors
        s.AddTool(mcp.Tool{
                Name:        "prtg_top_sensors",
                Description: "Get top sensors ranked by various metrics (uptime, downtime, or alerts).",
                InputSchema: mcp.ToolInputSchema{
                        Type: "object",
                        Properties: map[string]interface{}{
                                "metric": map[string]interface{}{
                                        "type":        "string",
                                        "description": "Metric to rank by: 'uptime', 'downtime', or 'alerts'",
                                        "enum":        []string{"uptime", "downtime", "alerts"},
                                        "default":     "downtime",
                                },
                                "sensor_type": map[string]string{
                                        "type":        "string",
                                        "description": "Filter by sensor type (e.g., 'ping', 'http')",
                                },
                                "limit": map[string]interface{}{
                                        "type":        "integer",
                                        "description": "Number of results to return (default: 10)",
                                        "default":     10,
                                },
                                "hours": map[string]interface{}{
                                        "type":        "integer",
                                        "description": "Time window in hours (default: 24)",
                                        "default":     24,
                                },
                        },
                },
        }, h.handleTopSensors)

        // Tool 6: prtg_query_sql
        s.AddTool(mcp.Tool{
                Name: "prtg_query_sql",
                Description: "Execute a custom SQL query on the PRTG database (SELECT only). Use for advanced queries not covered by other tools.\n\n" +
                        "IMPORTANT - Table Schema:\n" +
                        "- prtg_sensor: id, name, sensor_type, prtg_device_id, status, priority, message, last_check_utc, full_path\n" +
                        "- prtg_device: id, name\n" +
                        "- prtg_sensor_path: sensor_id, path\n" +
                        "- prtg_tag: id, name\n" +
                        "- prtg_sensor_tag: prtg_sensor_id, prtg_tag_id\n\n" +
                        "Use these EXACT table names in your queries. Status codes: 3=Up, 4=Warning, 5=Down, 7=Paused, 13=Unknown",
                InputSchema: mcp.ToolInputSchema{
                        Type: "object",
                        Properties: map[string]interface{}{
                                "query": map[string]string{
                                        "type":        "string",
                                        "description": "SQL SELECT query to execute (use table names: prtg_sensor, prtg_device, etc.)",
                                },
                                "limit": map[string]interface{}{
                                        "type":        "integer",
                                        "description": "Maximum number of results (default: 100)",
                                        "default":     100,
                                },
                        },
                        Required: []string{"query"},
                },
        }, h.handleCustomQuery)
}</span>

// handleGetSensors handles the prtg_get_sensors tool
func (h *ToolHandler) handleGetSensors(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) <span class="cov0" title="0">{
        h.logger.Info().Interface("arguments", request.Params.Arguments).Msg("handling prtg_get_sensors")

        var args struct {
                DeviceName string `json:"device_name"`
                SensorName string `json:"sensor_name"`
                Status     *int   `json:"status"`
                Tags       string `json:"tags"`
                Limit      int    `json:"limit"`
        }

        if err := parseArguments(request.Params.Arguments, &amp;args); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid arguments: %w", err)
        }</span>

        <span class="cov0" title="0">if args.Limit &lt;= 0 </span><span class="cov0" title="0">{
                args.Limit = 1000 // Default to reasonable limit, user can override
        }</span>

        <span class="cov0" title="0">h.logger.Debug().
                Str("device_name", args.DeviceName).
                Str("sensor_name", args.SensorName).
                Interface("status", args.Status).
                Str("tags", args.Tags).
                Int("limit", args.Limit).
                Msg("calling db.GetSensors")

        // Create a new context with longer timeout to avoid cancellation
        // The parent context from MCP might be cancelled too early
        dbCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        sensors, err := h.db.GetSensors(dbCtx, args.DeviceName, args.SensorName, args.Status, args.Tags, args.Limit)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error().Err(err).Msg("db.GetSensors failed")
                return nil, fmt.Errorf("failed to get sensors: %w", err)
        }</span>

        <span class="cov0" title="0">h.logger.Debug().Int("count", len(sensors)).Msg("db.GetSensors returned")

        result, err := formatResult(sensors, len(sensors))
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error().Err(err).Msg("formatResult failed")
                return nil, err
        }</span>

        // Calculate response size
        <span class="cov0" title="0">responseSize := 0
        if len(result.Content) &gt; 0 </span><span class="cov0" title="0">{
                if textContent, ok := result.Content[0].(mcp.TextContent); ok </span><span class="cov0" title="0">{
                        responseSize = len(textContent.Text)
                }</span>
        }

        <span class="cov0" title="0">h.logger.Info().
                Int("sensors_count", len(sensors)).
                Int("response_size_bytes", responseSize).
                Msg("returning result to MCP client")

        return result, nil</span>
}

// handleGetSensorStatus handles the prtg_get_sensor_status tool
func (h *ToolHandler) handleGetSensorStatus(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) <span class="cov0" title="0">{
        h.logger.Info().Interface("arguments", request.Params.Arguments).Msg("handling prtg_get_sensor_status")

        var args struct {
                SensorID int `json:"sensor_id"`
        }

        if err := parseArguments(request.Params.Arguments, &amp;args); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid arguments: %w", err)
        }</span>

        <span class="cov0" title="0">if args.SensorID &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("sensor_id must be greater than 0")
        }</span>

        // Create a new context with longer timeout
        <span class="cov0" title="0">dbCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        sensor, err := h.db.GetSensorByID(dbCtx, args.SensorID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get sensor: %w", err)
        }</span>

        <span class="cov0" title="0">return formatResult(sensor, 1)</span>
}

// handleGetAlerts handles the prtg_get_alerts tool
func (h *ToolHandler) handleGetAlerts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) <span class="cov0" title="0">{
        h.logger.Info().Interface("arguments", request.Params.Arguments).Msg("handling prtg_get_alerts")

        var args struct {
                Hours      int    `json:"hours"`
                Status     *int   `json:"status"`
                DeviceName string `json:"device_name"`
        }

        if err := parseArguments(request.Params.Arguments, &amp;args); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid arguments: %w", err)
        }</span>

        <span class="cov0" title="0">if args.Hours == 0 </span><span class="cov0" title="0">{
                args.Hours = 24
        }</span>

        // Create a new context with longer timeout
        <span class="cov0" title="0">dbCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        sensors, err := h.db.GetAlerts(dbCtx, args.Hours, args.Status, args.DeviceName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get alerts: %w", err)
        }</span>

        <span class="cov0" title="0">return formatResult(sensors, len(sensors))</span>
}

// handleDeviceOverview handles the prtg_device_overview tool
func (h *ToolHandler) handleDeviceOverview(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) <span class="cov0" title="0">{
        h.logger.Info().Interface("arguments", request.Params.Arguments).Msg("handling prtg_device_overview")

        var args struct {
                DeviceName string `json:"device_name"`
        }

        if err := parseArguments(request.Params.Arguments, &amp;args); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid arguments: %w", err)
        }</span>

        <span class="cov0" title="0">if args.DeviceName == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("device_name is required")
        }</span>

        // Create a new context with longer timeout
        <span class="cov0" title="0">dbCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        overview, err := h.db.GetDeviceOverview(dbCtx, args.DeviceName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get device overview: %w", err)
        }</span>

        <span class="cov0" title="0">return formatResult(overview, overview.TotalSensors)</span>
}

// handleTopSensors handles the prtg_top_sensors tool
func (h *ToolHandler) handleTopSensors(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) <span class="cov0" title="0">{
        h.logger.Info().Interface("arguments", request.Params.Arguments).Msg("handling prtg_top_sensors")

        var args struct {
                Metric     string `json:"metric"`
                SensorType string `json:"sensor_type"`
                Limit      int    `json:"limit"`
                Hours      int    `json:"hours"`
        }

        if err := parseArguments(request.Params.Arguments, &amp;args); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid arguments: %w", err)
        }</span>

        <span class="cov0" title="0">if args.Metric == "" </span><span class="cov0" title="0">{
                args.Metric = "downtime"
        }</span>

        <span class="cov0" title="0">if args.Limit &lt;= 0 </span><span class="cov0" title="0">{
                args.Limit = 10
        }</span>

        <span class="cov0" title="0">if args.Hours &lt;= 0 </span><span class="cov0" title="0">{
                args.Hours = 24
        }</span>

        // Create a new context with longer timeout
        <span class="cov0" title="0">dbCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        sensors, err := h.db.GetTopSensors(dbCtx, args.Metric, args.SensorType, args.Limit, args.Hours)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get top sensors: %w", err)
        }</span>

        <span class="cov0" title="0">return formatResult(sensors, len(sensors))</span>
}

// handleCustomQuery handles the prtg_query_sql tool
func (h *ToolHandler) handleCustomQuery(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) <span class="cov0" title="0">{
        h.logger.Info().Interface("arguments", request.Params.Arguments).Msg("handling prtg_query_sql")

        var args struct {
                Query string `json:"query"`
                Limit int    `json:"limit"`
        }

        if err := parseArguments(request.Params.Arguments, &amp;args); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid arguments: %w", err)
        }</span>

        <span class="cov0" title="0">if args.Query == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query is required")
        }</span>

        <span class="cov0" title="0">if args.Limit &lt;= 0 </span><span class="cov0" title="0">{
                args.Limit = 100
        }</span>

        <span class="cov0" title="0">h.logger.Debug().
                Str("query", args.Query).
                Int("limit", args.Limit).
                Msg("calling db.ExecuteCustomQuery")

        // Create a new context with longer timeout to avoid cancellation
        dbCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        results, err := h.db.ExecuteCustomQuery(dbCtx, args.Query, args.Limit)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error().Err(err).Msg("db.ExecuteCustomQuery failed")
                return nil, fmt.Errorf("query execution failed: %w", err)
        }</span>

        <span class="cov0" title="0">h.logger.Debug().Int("result_count", len(results)).Msg("db.ExecuteCustomQuery returned")

        return formatResult(results, len(results))</span>
}

// parseArguments parses tool arguments from interface{} to target struct
func parseArguments(args, target interface{}) error <span class="cov0" title="0">{
        data, err := json.Marshal(args)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return json.Unmarshal(data, target)</span>
}

// formatResult formats the response data as MCP tool result
func formatResult(data interface{}, count int) (*mcp.CallToolResult, error) <span class="cov0" title="0">{
        jsonData, err := json.MarshalIndent(data, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal result: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;mcp.CallToolResult{
                Content: []interface{}{
                        mcp.TextContent{
                                Type: "text",
                                Text: fmt.Sprintf("Found %d result(s):\n\n%s", count, string(jsonData)),
                        },
                },
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package server

import (
        "context"
        "crypto/tls"
        "fmt"
        "net/http"
        "net/http/httputil"
        "net/url"
        "time"

        server "github.com/mark3labs/mcp-go/server"
        "github.com/matthieu/mcp-server-prtg/internal/database"
        "github.com/matthieu/mcp-server-prtg/internal/services/configuration"
        "github.com/matthieu/mcp-server-prtg/internal/services/logger"
        "github.com/matthieu/mcp-server-prtg/internal/version"
)

// SSEServerV2 wraps the MCP SSE server with authentication and TLS.
type SSEServerV2 struct {
        mcpServer    *server.MCPServer
        sseServer    *server.SSEServer
        proxyServer  *http.Server
        config       *configuration.Configuration
        logger       *logger.ModuleLogger
        db           *database.DB
        baseURL      string
        internalAddr string
        externalAddr string
}

// NewSSEServerV2 creates a new SSE-based MCP server with authentication proxy.
func NewSSEServerV2(mcpServer *server.MCPServer, db *database.DB, config *configuration.Configuration, baseLogger *logger.Logger) *SSEServerV2 <span class="cov0" title="0">{
        logger := logger.NewModuleLogger(baseLogger, logger.ModuleServer)

        // Get public URL for SSE endpoint (uses public_url from config if set)
        baseURL := config.GetPublicURL()

        // Internal SSE server runs on a different port (no auth, localhost only)
        internalAddr := "127.0.0.1:18443"

        // External address for binding
        externalAddr := config.GetServerAddress()

        return &amp;SSEServerV2{
                mcpServer:    mcpServer,
                config:       config,
                logger:       logger,
                db:           db,
                baseURL:      baseURL,
                internalAddr: internalAddr,
                externalAddr: externalAddr,
        }
}</span>

// Start starts the SSE server with authentication proxy.
func (s *SSEServerV2) Start(_ context.Context) error <span class="cov0" title="0">{
        s.logger.Info().
                Str("external_address", s.externalAddr).
                Str("internal_address", s.internalAddr).
                Bool("tls", s.config.IsTLSEnabled()).
                Msg("Starting MCP Server with SSE transport (v2)")

        // Create internal SSE server with public base URL
        // The SSE server will append /message to this URL automatically
        s.sseServer = server.NewSSEServer(s.mcpServer, s.baseURL)

        // Start internal SSE server in background
        go func() </span><span class="cov0" title="0">{
                s.logger.Info().Str("address", s.internalAddr).Msg("Starting internal SSE server")
                if err := s.sseServer.Start(s.internalAddr); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error().Err(err).Msg("Internal SSE server error")
                }</span>
        }()

        // Wait a bit for internal server to start
        <span class="cov0" title="0">time.Sleep(500 * time.Millisecond)

        // Create authentication proxy
        if err := s.startAuthProxy(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start auth proxy: %w", err)
        }</span>

        // Log startup information
        <span class="cov0" title="0">s.logStartupInfo()

        return nil</span>
}

// startAuthProxy starts the external authentication proxy.
func (s *SSEServerV2) startAuthProxy() error <span class="cov0" title="0">{
        // Parse internal URL
        internalURL, err := url.Parse(fmt.Sprintf("http://%s", s.internalAddr))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse internal URL: %w", err)
        }</span>

        // Create reverse proxy to internal SSE server
        <span class="cov0" title="0">proxy := httputil.NewSingleHostReverseProxy(internalURL)

        // Custom director to preserve headers
        originalDirector := proxy.Director
        proxy.Director = func(req *http.Request) </span><span class="cov0" title="0">{
                originalDirector(req)
                req.Host = internalURL.Host
        }</span>

        // Create authenticated handler
        <span class="cov0" title="0">authHandler := s.createAuthMiddleware()(proxy.ServeHTTP)

        // Create mux with additional endpoints
        mux := http.NewServeMux()

        // SSE endpoints (proxied with auth)
        mux.HandleFunc("/sse", authHandler)
        mux.HandleFunc("/message", authHandler)

        // Health check endpoint (no auth)
        mux.HandleFunc("/health", s.handleHealth)

        // Status endpoint (auth required)
        mux.HandleFunc("/status", s.createAuthMiddleware()(s.handleStatus))

        // Create HTTP server
        // For SSE, we need long/no timeouts as connections stay open
        s.proxyServer = &amp;http.Server{
                Addr:         s.externalAddr,
                Handler:      mux,
                ReadTimeout:  0, // No read timeout for SSE
                WriteTimeout: 0, // No write timeout for SSE (long-lived connections)
                IdleTimeout:  0, // No idle timeout for SSE (connections stay open)
        }

        // Start server (with or without TLS)
        go s.startProxyServer()

        return nil</span>
}

// startProxyServer starts the proxy HTTP server.
func (s *SSEServerV2) startProxyServer() <span class="cov0" title="0">{
        var err error

        if s.config.IsTLSEnabled() </span><span class="cov0" title="0">{
                // Load TLS configuration
                certFile := s.config.GetTLSCertFile()
                keyFile := s.config.GetTLSKeyFile()

                // Configure TLS
                tlsConfig := &amp;tls.Config{
                        MinVersion:               tls.VersionTLS12,
                        PreferServerCipherSuites: true,
                }

                s.proxyServer.TLSConfig = tlsConfig

                s.logger.Info().
                        Str("cert", certFile).
                        Str("key", keyFile).
                        Msg("Starting HTTPS proxy server")

                err = s.proxyServer.ListenAndServeTLS(certFile, keyFile)
        }</span> else<span class="cov0" title="0"> {
                s.logger.Warn().Msg("Starting HTTP proxy server (TLS disabled - not recommended for production)")
                err = s.proxyServer.ListenAndServe()
        }</span>

        <span class="cov0" title="0">if err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                s.logger.Error().Err(err).Msg("HTTP proxy server error")
        }</span>
}

// createAuthMiddleware creates authentication middleware using Bearer token.
func (s *SSEServerV2) createAuthMiddleware() func(http.HandlerFunc) http.HandlerFunc <span class="cov0" title="0">{
        expectedToken := s.config.GetAPIKey()

        return func(next http.HandlerFunc) http.HandlerFunc </span><span class="cov0" title="0">{
                return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Extract Bearer token from Authorization header
                        authHeader := r.Header.Get("Authorization")
                        var providedToken string

                        if authHeader != "" </span><span class="cov0" title="0">{
                                // Check for "Bearer &lt;token&gt;" format
                                const bearerPrefix = "Bearer "
                                if len(authHeader) &gt; len(bearerPrefix) &amp;&amp; authHeader[:len(bearerPrefix)] == bearerPrefix </span><span class="cov0" title="0">{
                                        providedToken = authHeader[len(bearerPrefix):]
                                }</span>
                        }

                        // Fallback: check query parameter (for SSE compatibility)
                        <span class="cov0" title="0">if providedToken == "" </span><span class="cov0" title="0">{
                                providedToken = r.URL.Query().Get("token")
                        }</span>

                        // Validate token
                        <span class="cov0" title="0">if providedToken != expectedToken </span><span class="cov0" title="0">{
                                s.logger.Warn().
                                        Str("remote_addr", r.RemoteAddr).
                                        Str("path", r.URL.Path).
                                        Str("method", r.Method).
                                        Bool("has_auth_header", authHeader != "").
                                        Msg("Unauthorized access attempt")

                                w.Header().Set("WWW-Authenticate", "Bearer realm=\"MCP Server PRTG\"")
                                http.Error(w, "Unauthorized: Missing or invalid Bearer token", http.StatusUnauthorized)
                                return
                        }</span>

                        // Token valid, continue
                        <span class="cov0" title="0">s.logger.Debug().
                                Str("remote_addr", r.RemoteAddr).
                                Str("path", r.URL.Path).
                                Str("method", r.Method).
                                Msg("Authenticated request")

                        next(w, r)</span>
                }
        }
}

// handleHealth handles health check requests.
func (s *SSEServerV2) handleHealth(w http.ResponseWriter, _ *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        fmt.Fprintf(w, `{"status":"healthy","timestamp":"%s"}`, time.Now().Format(time.RFC3339))
}</span>

// handleStatus handles status requests (authenticated).
func (s *SSEServerV2) handleStatus(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")

        // Check database health
        dbStatus := "connected"
        dbError := ""
        ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)
        defer cancel()

        if s.db != nil </span><span class="cov0" title="0">{
                if err := s.db.Health(ctx); err != nil </span><span class="cov0" title="0">{
                        dbStatus = "disconnected"
                        dbError = err.Error()
                        s.logger.Warn().Err(err).Msg("Database health check failed")
                }</span>
        } else<span class="cov0" title="0"> {
                dbStatus = "not_configured"
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)

        status := fmt.Sprintf(`{
                "status":"running",
                "version":"%s",
                "transport":"sse",
                "tls_enabled":%t,
                "base_url":"%s",
                "mcp_tools":6,
                "database":{
                        "status":"%s",
                        "error":"%s"
                },
                "timestamp":"%s"
        }`, version.Get(), s.config.IsTLSEnabled(), s.baseURL, dbStatus, dbError, time.Now().Format(time.RFC3339))

        fmt.Fprint(w, status)</span>
}

// Shutdown gracefully shuts down the server.
func (s *SSEServerV2) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        s.logger.Info().Msg("Shutting down SSE server")

        var firstErr error

        // Shutdown proxy server
        if s.proxyServer != nil </span><span class="cov0" title="0">{
                if err := s.proxyServer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error().Err(err).Msg("Error shutting down proxy server")
                        if firstErr == nil </span><span class="cov0" title="0">{
                                firstErr = err
                        }</span>
                }
        }

        // Shutdown internal SSE server
        <span class="cov0" title="0">if s.sseServer != nil </span><span class="cov0" title="0">{
                if err := s.sseServer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error().Err(err).Msg("Error shutting down SSE server")
                        if firstErr == nil </span><span class="cov0" title="0">{
                                firstErr = err
                        }</span>
                }
        }

        <span class="cov0" title="0">if firstErr == nil </span><span class="cov0" title="0">{
                s.logger.Info().Msg("SSE server shut down successfully")
        }</span>

        <span class="cov0" title="0">return firstErr</span>
}

// logStartupInfo logs startup information.
func (s *SSEServerV2) logStartupInfo() <span class="cov0" title="0">{
        protocol := "HTTP"
        if s.config.IsTLSEnabled() </span><span class="cov0" title="0">{
                protocol = "HTTPS"
        }</span>

        <span class="cov0" title="0">s.logger.Info().Msgf(`
╔════════════════════════════════════════════════════════════════╗
║         MCP Server PRTG - SSE Transport Started (v2)           ║
╠════════════════════════════════════════════════════════════════╣
║  Protocol:     %s                                           ║
║  External:     %s                                    ║
║  Internal:     %s                              ║
║  Base URL:     %s                        ║
║  MCP Tools:    6 tools registered                             ║
║  Endpoints:                                                    ║
║    - GET  /sse      (SSE stream - authenticated)              ║
║    - POST /message  (RPC messages - authenticated)            ║
║    - GET  /health   (Health check - public)                   ║
║    - GET  /status   (Server status - authenticated)           ║
╠════════════════════════════════════════════════════════════════╣
║  Authentication: Bearer Token (RFC 6750)                       ║
║    - Header: Authorization: Bearer &lt;token&gt;                     ║
║    - Query:  ?token=&lt;token&gt; (fallback for SSE)                 ║
║  Token: %s                                    ║
╚════════════════════════════════════════════════════════════════╝
        `, protocol, s.externalAddr, s.internalAddr, s.baseURL, maskAPIKey(s.config.GetAPIKey()))</span>
}

// maskAPIKey masks the API key for logging.
func maskAPIKey(key string) string <span class="cov0" title="0">{
        if len(key) &lt;= 8 </span><span class="cov0" title="0">{
                return "***"
        }</span>

        <span class="cov0" title="0">return key[:4] + "..." + key[len(key)-4:]</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package configuration

import (
        "context"
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/pem"
        "fmt"
        "math/big"
        "net"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/fsnotify/fsnotify"
        "github.com/matthieu/mcp-server-prtg/internal/cliArgs"
        "github.com/matthieu/mcp-server-prtg/internal/services/logger"
        "gopkg.in/yaml.v3"
)

const (
        CurrentConfigVersion = 1
        DefaultConfigFile    = "config.yaml"
)

// Configuration represents the complete server configuration.
type Configuration struct {
        configPath string
        logger     *logger.ModuleLogger
        watcher    *fsnotify.Watcher
        args       *cliArgs.ParsedArgs

        // Configuration data
        data ConfigData

        // Callbacks
        onChangeCallbacks []func()
}

// ConfigData represents the YAML configuration structure.
type ConfigData struct {
        ConfigVersion int            `yaml:"config_version"`
        Server        ServerConfig   `yaml:"server"`
        Database      DatabaseConfig `yaml:"database"`
        Logging       LoggingConfig  `yaml:"logging"`
}

// ServerConfig holds HTTP server configuration.
type ServerConfig struct {
        APIKey       string `yaml:"api_key"`       // API Key (Bearer token)
        BindAddress  string `yaml:"bind_address"`  // Address to bind to (e.g., 0.0.0.0)
        Port         int    `yaml:"port"`          // Port to listen on
        PublicURL    string `yaml:"public_url"`    // Public URL for SSE endpoint (optional, e.g., https://dash999.hibouvision.com:8443)
        EnableTLS    bool   `yaml:"enable_tls"`    // Enable HTTPS
        CertFile     string `yaml:"cert_file"`     // TLS certificate file
        KeyFile      string `yaml:"key_file"`      // TLS private key file
        ReadTimeout  int    `yaml:"read_timeout"`  // Read timeout in seconds
        WriteTimeout int    `yaml:"write_timeout"` // Write timeout in seconds
}

// DatabaseConfig holds database connection settings.
type DatabaseConfig struct {
        Host     string `yaml:"host"`
        Port     int    `yaml:"port"`
        Name     string `yaml:"name"`
        User     string `yaml:"user"`
        Password string `yaml:"password"`
        SSLMode  string `yaml:"sslmode"`
}

// LoggingConfig holds logging settings.
type LoggingConfig struct {
        Level      string `yaml:"level"`
        File       string `yaml:"file"`
        MaxSizeMB  int    `yaml:"max_size_mb"`
        MaxBackups int    `yaml:"max_backups"`
        MaxAgeDays int    `yaml:"max_age_days"`
        Compress   bool   `yaml:"compress"`
}

// NewConfiguration creates a new configuration manager.
func NewConfiguration(args *cliArgs.ParsedArgs, baseLogger *logger.Logger) (*Configuration, error) <span class="cov0" title="0">{
        logger := logger.NewModuleLogger(baseLogger, logger.ModuleConfiguration)

        config := &amp;Configuration{
                configPath:        args.ConfigPath,
                logger:            logger,
                args:              args,
                onChangeCallbacks: make([]func(), 0),
        }

        // Load or create configuration
        if err := config.loadOrCreate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load configuration: %w", err)
        }</span>

        // Initialize file watcher
        <span class="cov0" title="0">if err := config.initWatcher(); err != nil </span><span class="cov0" title="0">{
                logger.Warn().Err(err).Msg("Failed to initialize config file watcher")
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

// loadOrCreate loads existing config or creates a new one.
func (c *Configuration) loadOrCreate() error <span class="cov0" title="0">{
        if _, err := os.Stat(c.configPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                c.logger.Info().Str("path", c.configPath).Msg("Configuration file not found, creating default")
                return c.createDefaultConfiguration()
        }</span>

        <span class="cov0" title="0">return c.loadConfiguration()</span>
}

// loadConfiguration loads configuration from YAML file.
func (c *Configuration) loadConfiguration() error <span class="cov0" title="0">{
        data, err := os.ReadFile(c.configPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov0" title="0">if err := yaml.Unmarshal(data, &amp;c.data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse config file: %w", err)
        }</span>

        <span class="cov0" title="0">c.logger.Info().
                Str("path", c.configPath).
                Int("version", c.data.ConfigVersion).
                Msg("Configuration loaded successfully")

        return nil</span>
}

// createDefaultConfiguration creates a default configuration file.
func (c *Configuration) createDefaultConfiguration() error <span class="cov0" title="0">{
        // Generate API key if not provided
        apiKey := c.args.AuthKey

        if apiKey == "" </span><span class="cov0" title="0">{
                var err error
                apiKey, err = generateUUIDKey()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to generate API key: %w", err)
                }</span>
                <span class="cov0" title="0">c.logger.Info().Msg("Generated new API key (Bearer token)")</span>
        }

        // Get absolute paths for certificates (relative to executable directory)
        // This ensures paths work correctly when running as a Windows service
        <span class="cov0" title="0">exePath, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get executable path: %w", err)
        }</span>
        <span class="cov0" title="0">exeDir := filepath.Dir(exePath)

        defaultCertFile := filepath.Join(exeDir, "certs", "server.crt")
        defaultKeyFile := filepath.Join(exeDir, "certs", "server.key")

        // On Windows, double backslashes for YAML compatibility
        // Windows accepts both C:\\path and C:/path but YAML needs escaped backslashes
        if filepath.Separator == '\\' </span><span class="cov0" title="0">{
                defaultCertFile = strings.ReplaceAll(defaultCertFile, "\\", "\\\\")
                defaultKeyFile = strings.ReplaceAll(defaultKeyFile, "\\", "\\\\")
        }</span>

        <span class="cov0" title="0">c.logger.Debug().
                Str("exe_dir", exeDir).
                Str("cert_file", defaultCertFile).
                Str("key_file", defaultKeyFile).
                Msg("Using executable directory for certificate paths")

        // Create default config
        c.data = ConfigData{
                ConfigVersion: CurrentConfigVersion,
                Server: ServerConfig{
                        APIKey:       apiKey,
                        BindAddress:  getOrDefault(c.args.BindAddress, "0.0.0.0"),
                        Port:         getOrDefaultInt(c.args.Port, 8443),
                        EnableTLS:    c.args.EnableHTTPS,
                        CertFile:     getOrDefault(c.args.CertFile, defaultCertFile),
                        KeyFile:      getOrDefault(c.args.KeyFile, defaultKeyFile),
                        ReadTimeout:  0, // No timeout for SSE connections
                        WriteTimeout: 0, // No timeout for SSE connections
                },
                Database: DatabaseConfig{
                        Host:     getOrDefault(c.args.DBHost, "localhost"),
                        Port:     getOrDefaultInt(c.args.DBPort, 5432),
                        Name:     getOrDefault(c.args.DBName, "prtg_data_exporter"),
                        User:     getOrDefault(c.args.DBUser, "prtg_reader"),
                        Password: c.args.DBPassword,
                        SSLMode:  getOrDefault(c.args.DBSSLMode, "disable"),
                },
                Logging: LoggingConfig{
                        Level:      getOrDefault(c.args.LogLevel, "info"),
                        File:       c.args.LogFile,
                        MaxSizeMB:  10,
                        MaxBackups: 5,
                        MaxAgeDays: 30,
                        Compress:   true,
                },
        }

        // Generate TLS certificates if enabled and not provided
        if c.data.Server.EnableTLS &amp;&amp; c.args.CertFile == "" </span><span class="cov0" title="0">{
                if err := c.generateTLSCertificates(); err != nil </span><span class="cov0" title="0">{
                        c.logger.Warn().Err(err).Msg("Failed to generate TLS certificates")
                }</span>
        }

        <span class="cov0" title="0">return c.saveConfiguration()</span>
}

// saveConfiguration saves configuration to YAML file.
func (c *Configuration) saveConfiguration() error <span class="cov0" title="0">{
        // For Windows paths, we need to generate YAML manually to ensure proper quoting
        // The yaml.Marshal doesn't add quotes around strings with backslashes
        var yamlData []byte
        var err error

        if filepath.Separator == '\\' </span><span class="cov0" title="0">{
                // On Windows, generate YAML manually with quoted paths
                yamlData, err = c.generateWindowsYAML()
        }</span> else<span class="cov0" title="0"> {
                // On Unix, use standard marshaller
                yamlData, err = yaml.Marshal(&amp;c.data)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        // Ensure directory exists
        <span class="cov0" title="0">dir := filepath.Dir(c.configPath)
        if err := os.MkdirAll(dir, 0750); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config directory: %w", err)
        }</span>

        // Write with restricted permissions (0600 for security)
        <span class="cov0" title="0">if err := os.WriteFile(c.configPath, yamlData, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov0" title="0">c.logger.Info().
                Str("path", c.configPath).
                Msg("Configuration saved successfully")

        return nil</span>
}

// generateWindowsYAML generates YAML with properly quoted Windows paths.
func (c *Configuration) generateWindowsYAML() ([]byte, error) <span class="cov0" title="0">{
        // Use yaml.Marshal for most fields, but manually format cert paths with quotes
        yamlData, err := yaml.Marshal(&amp;c.data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Replace unquoted Windows paths with quoted ones
        // This ensures YAML parsers correctly interpret backslashes
        <span class="cov0" title="0">yamlStr := string(yamlData)

        // Quote cert_file if it contains backslashes and isn't already quoted
        certFile := c.data.Server.CertFile
        if strings.Contains(certFile, "\\") &amp;&amp; !strings.HasPrefix(certFile, "\"") </span><span class="cov0" title="0">{
                yamlStr = strings.ReplaceAll(yamlStr,
                        fmt.Sprintf("cert_file: %s", certFile),
                        fmt.Sprintf("cert_file: \"%s\"", certFile))
        }</span>

        // Quote key_file if it contains backslashes and isn't already quoted
        <span class="cov0" title="0">keyFile := c.data.Server.KeyFile
        if strings.Contains(keyFile, "\\") &amp;&amp; !strings.HasPrefix(keyFile, "\"") </span><span class="cov0" title="0">{
                yamlStr = strings.ReplaceAll(yamlStr,
                        fmt.Sprintf("key_file: %s", keyFile),
                        fmt.Sprintf("key_file: \"%s\"", keyFile))
        }</span>

        <span class="cov0" title="0">return []byte(yamlStr), nil</span>
}

// generateTLSCertificates generates self-signed TLS certificate and key.
func (c *Configuration) generateTLSCertificates() error <span class="cov0" title="0">{
        // Check if certificates already exist - don't overwrite them
        certExists := false
        keyExists := false

        if _, err := os.Stat(c.data.Server.CertFile); err == nil </span><span class="cov0" title="0">{
                certExists = true
        }</span>
        <span class="cov0" title="0">if _, err := os.Stat(c.data.Server.KeyFile); err == nil </span><span class="cov0" title="0">{
                keyExists = true
        }</span>

        // If both certificate files exist, don't regenerate (user may have provided their own)
        <span class="cov0" title="0">if certExists &amp;&amp; keyExists </span><span class="cov0" title="0">{
                c.logger.Info().
                        Str("cert", c.data.Server.CertFile).
                        Str("key", c.data.Server.KeyFile).
                        Msg("TLS certificates already exist, skipping generation")
                return nil
        }</span>

        <span class="cov0" title="0">c.logger.Info().Msg("Generating self-signed TLS certificates")

        // Create certs directory
        certsDir := filepath.Dir(c.data.Server.CertFile)
        if err := os.MkdirAll(certsDir, 0750); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create certs directory: %w", err)
        }</span>

        // Generate private key
        <span class="cov0" title="0">privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate private key: %w", err)
        }</span>

        // Create certificate template
        <span class="cov0" title="0">template := x509.Certificate{
                SerialNumber: big.NewInt(time.Now().Unix()),
                Subject: pkix.Name{
                        Organization: []string{"MCP Server PRTG"},
                        CommonName:   "localhost",
                },
                NotBefore:             time.Now(),
                NotAfter:              time.Now().Add(365 * 24 * time.Hour), // 1 year
                KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
                ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
                BasicConstraintsValid: true,
        }

        // Add SANs (Subject Alternative Names)
        template.DNSNames = []string{"localhost"}
        template.IPAddresses = []net.IP{net.ParseIP("127.0.0.1"), net.ParseIP("::1")}

        // Generate certificate
        certDER, err := x509.CreateCertificate(rand.Reader, &amp;template, &amp;template, &amp;privateKey.PublicKey, privateKey)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create certificate: %w", err)
        }</span>

        // Encode certificate to PEM
        <span class="cov0" title="0">certPEM := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "CERTIFICATE",
                Bytes: certDER,
        })

        // Encode private key to PEM
        keyPEM := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "RSA PRIVATE KEY",
                Bytes: x509.MarshalPKCS1PrivateKey(privateKey),
        })

        // Write certificate file (0600 - secure permissions)
        if err := os.WriteFile(c.data.Server.CertFile, certPEM, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write certificate: %w", err)
        }</span>

        // Write private key file (0600 - owner only)
        <span class="cov0" title="0">if err := os.WriteFile(c.data.Server.KeyFile, keyPEM, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write private key: %w", err)
        }</span>

        <span class="cov0" title="0">c.logger.Info().
                Str("cert", c.data.Server.CertFile).
                Str("key", c.data.Server.KeyFile).
                Msg("TLS certificates generated successfully")

        return nil</span>
}

// generateUUIDKey generates a UUID v4 for API key.
func generateUUIDKey() (string, error) <span class="cov0" title="0">{
        uuid := make([]byte, 16)
        if _, err := rand.Read(uuid); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate random bytes: %w", err)
        }</span>

        // Set version (4) and variant bits
        <span class="cov0" title="0">uuid[6] = (uuid[6] &amp; 0x0f) | 0x40 // Version 4
        uuid[8] = (uuid[8] &amp; 0x3f) | 0x80 // Variant bits

        return fmt.Sprintf("%08x-%04x-%04x-%04x-%012x",
                uuid[0:4], uuid[4:6], uuid[6:8], uuid[8:10], uuid[10:16]), nil</span>
}

// Get methods for accessing configuration.

// GetAPIKey returns the API key (Bearer token).
func (c *Configuration) GetAPIKey() string <span class="cov0" title="0">{
        return c.data.Server.APIKey
}</span>

// GetServerAddress returns the full server address.
func (c *Configuration) GetServerAddress() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%d", c.data.Server.BindAddress, c.data.Server.Port)
}</span>

// GetPublicURL returns the public URL (for SSE endpoint URLs).
// If not configured, falls back to bind_address:port.
func (c *Configuration) GetPublicURL() string <span class="cov0" title="0">{
        if c.data.Server.PublicURL != "" </span><span class="cov0" title="0">{
                return c.data.Server.PublicURL
        }</span>

        // Fallback to constructed URL from bind address
        <span class="cov0" title="0">protocol := "http"
        if c.data.Server.EnableTLS </span><span class="cov0" title="0">{
                protocol = "https"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s://%s:%d", protocol, c.data.Server.BindAddress, c.data.Server.Port)</span>
}

// GetDatabaseConnectionString returns the PostgreSQL connection string.
func (c *Configuration) GetDatabaseConnectionString() string <span class="cov0" title="0">{
        return fmt.Sprintf("host=%s port=%d dbname=%s user=%s password=%s sslmode=%s",
                c.data.Database.Host,
                c.data.Database.Port,
                c.data.Database.Name,
                c.data.Database.User,
                c.data.Database.Password,
                c.data.Database.SSLMode,
        )
}</span>

// GetDatabaseHost returns the database host.
func (c *Configuration) GetDatabaseHost() string <span class="cov0" title="0">{
        return c.data.Database.Host
}</span>

// GetDatabasePort returns the database port.
func (c *Configuration) GetDatabasePort() int <span class="cov0" title="0">{
        return c.data.Database.Port
}</span>

// GetDatabaseName returns the database name.
func (c *Configuration) GetDatabaseName() string <span class="cov0" title="0">{
        return c.data.Database.Name
}</span>

// GetDatabaseUser returns the database user.
func (c *Configuration) GetDatabaseUser() string <span class="cov0" title="0">{
        return c.data.Database.User
}</span>

// GetDatabaseSSLMode returns the database SSL mode.
func (c *Configuration) GetDatabaseSSLMode() string <span class="cov0" title="0">{
        return c.data.Database.SSLMode
}</span>

// IsTLSEnabled returns whether TLS is enabled.
func (c *Configuration) IsTLSEnabled() bool <span class="cov0" title="0">{
        return c.data.Server.EnableTLS
}</span>

// GetTLSCertFile returns the TLS certificate file path.
func (c *Configuration) GetTLSCertFile() string <span class="cov0" title="0">{
        return c.data.Server.CertFile
}</span>

// GetTLSKeyFile returns the TLS private key file path.
func (c *Configuration) GetTLSKeyFile() string <span class="cov0" title="0">{
        return c.data.Server.KeyFile
}</span>

// GetReadTimeout returns the server read timeout.
func (c *Configuration) GetReadTimeout() time.Duration <span class="cov0" title="0">{
        return time.Duration(c.data.Server.ReadTimeout) * time.Second
}</span>

// GetWriteTimeout returns the server write timeout.
func (c *Configuration) GetWriteTimeout() time.Duration <span class="cov0" title="0">{
        return time.Duration(c.data.Server.WriteTimeout) * time.Second
}</span>

// Helper functions.

func getOrDefault(value, defaultValue string) string <span class="cov0" title="0">{
        if value != "" </span><span class="cov0" title="0">{
                return value
        }</span>

        <span class="cov0" title="0">return defaultValue</span>
}

func getOrDefaultInt(value, defaultValue int) int <span class="cov0" title="0">{
        if value != 0 </span><span class="cov0" title="0">{
                return value
        }</span>

        <span class="cov0" title="0">return defaultValue</span>
}

// initWatcher initializes file watcher for hot-reload.
func (c *Configuration) initWatcher() error <span class="cov0" title="0">{
        watcher, err := fsnotify.NewWatcher()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create file watcher: %w", err)
        }</span>

        <span class="cov0" title="0">if err := watcher.Add(c.configPath); err != nil </span><span class="cov0" title="0">{
                watcher.Close()
                return fmt.Errorf("failed to watch config file: %w", err)
        }</span>

        <span class="cov0" title="0">c.watcher = watcher

        // Start watching in background
        go c.watchConfigFile()

        c.logger.Info().Str("path", c.configPath).Msg("Config file watcher initialized")

        return nil</span>
}

// watchConfigFile watches for configuration file changes.
func (c *Configuration) watchConfigFile() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case event, ok := &lt;-c.watcher.Events:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">if event.Op&amp;fsnotify.Write == fsnotify.Write </span><span class="cov0" title="0">{
                                c.logger.Info().Str("path", event.Name).Msg("Configuration file changed, reloading")

                                if err := c.loadConfiguration(); err != nil </span><span class="cov0" title="0">{
                                        c.logger.Error().Err(err).Msg("Failed to reload configuration")
                                        continue</span>
                                }

                                // Notify callbacks
                                <span class="cov0" title="0">for _, callback := range c.onChangeCallbacks </span><span class="cov0" title="0">{
                                        callback()
                                }</span>
                        }

                case err, ok := &lt;-c.watcher.Errors:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">c.logger.Error().Err(err).Msg("File watcher error")</span>
                }
        }
}

// OnConfigChanged registers a callback for configuration changes.
func (c *Configuration) OnConfigChanged(callback func()) <span class="cov0" title="0">{
        c.onChangeCallbacks = append(c.onChangeCallbacks, callback)
}</span>

// Shutdown stops the configuration manager.
func (c *Configuration) Shutdown(_ context.Context) error <span class="cov0" title="0">{
        if c.watcher != nil </span><span class="cov0" title="0">{
                return c.watcher.Close()
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package logger

import (
        "io"
        "os"
        "path/filepath"
        "sync"

        "github.com/kardianos/service"
        "github.com/matthieu/mcp-server-prtg/internal/cliArgs"
        "github.com/rs/zerolog"
        "gopkg.in/natefinch/lumberjack.v2"
)

// Logger wraps zerolog.Logger.
type Logger = zerolog.Logger

// Module log level registry for selective debugging.
var (
        moduleLogLevels    = make(map[string]zerolog.Level)
        activeDebugModules = make(map[string]bool)
        selectiveDebugMode = false
        moduleLock         sync.RWMutex
)

// Available modules for debugging.
const (
        ModuleConfiguration = "configuration"
        ModuleServer        = "server"
        ModuleDatabase      = "database"
        ModuleHandlers      = "handlers"
        ModuleAuth          = "auth"
        ModuleService       = "service"
)

// NewSilentLogger creates a logger that discards all output (for quiet operations).
func NewSilentLogger() *Logger <span class="cov0" title="0">{
        // Create logger that writes to discard writer
        logger := zerolog.New(io.Discard).Level(zerolog.Disabled)
        return &amp;logger
}</span>

// NewLogger creates a new logger instance based on CLI arguments.
func NewLogger(args *cliArgs.ParsedArgs) *Logger <span class="cov0" title="0">{
        // Determine log level from configuration
        level := parseLogLevel(args.LogLevel)
        zerolog.SetGlobalLevel(level)

        // Build logger based on environment
        if service.Interactive() </span><span class="cov0" title="0">{
                return buildDevelopmentLogger(args, level)
        }</span>

        <span class="cov0" title="0">return buildProductionLogger(args, level)</span>
}

// buildDevelopmentLogger creates a logger for development/console mode.
func buildDevelopmentLogger(_ *cliArgs.ParsedArgs, level zerolog.Level) *Logger <span class="cov0" title="0">{
        // Console writer with colors
        consoleWriter := zerolog.ConsoleWriter{
                Out:        os.Stderr,
                TimeFormat: "15:04:05",
        }

        // Wrap with masking
        maskingWriter := NewMaskingWriter(consoleWriter)

        logger := zerolog.New(maskingWriter).
                Level(level).
                With().
                Timestamp().
                Caller().
                Logger()

        return &amp;logger
}</span>

// buildProductionLogger creates a logger for production/service mode.
func buildProductionLogger(args *cliArgs.ParsedArgs, level zerolog.Level) *Logger <span class="cov0" title="0">{
        // Ensure log directory exists
        logDir := filepath.Dir(args.LogFile)
        if err := os.MkdirAll(logDir, 0750); err != nil </span><span class="cov0" title="0">{
                // Fallback to stderr
                logger := zerolog.New(os.Stderr).Level(level).With().Timestamp().Logger()
                logger.Error().Err(err).Msg("Failed to create log directory, using stderr")
                return &amp;logger
        }</span>

        // Configure log rotation
        <span class="cov0" title="0">logRotator := &amp;lumberjack.Logger{
                Filename:   args.LogFile,
                MaxSize:    10,   // Megabytes
                MaxBackups: 5,    // Number of backups
                MaxAge:     30,   // Days
                Compress:   true, // Enable compression
        }

        // Multiple outputs
        writers := []io.Writer{NewMaskingWriter(logRotator)}

        // Add console in interactive mode
        if service.Interactive() </span><span class="cov0" title="0">{
                consoleWriter := zerolog.ConsoleWriter{
                        Out:        os.Stderr,
                        TimeFormat: "15:04:05",
                }
                writers = append(writers, NewMaskingWriter(consoleWriter))
        }</span>

        // Multi-writer
        <span class="cov0" title="0">logWriter := zerolog.MultiLevelWriter(writers...)

        logger := zerolog.New(logWriter).
                Level(level).
                With().
                Timestamp().
                Logger()

        return &amp;logger</span>
}

// parseLogLevel converts string to zerolog.Level.
func parseLogLevel(level string) zerolog.Level <span class="cov0" title="0">{
        switch level </span>{
        case "debug":<span class="cov0" title="0">
                return zerolog.DebugLevel</span>
        case "info":<span class="cov0" title="0">
                return zerolog.InfoLevel</span>
        case "warn":<span class="cov0" title="0">
                return zerolog.WarnLevel</span>
        case "error":<span class="cov0" title="0">
                return zerolog.ErrorLevel</span>
        default:<span class="cov0" title="0">
                return zerolog.InfoLevel</span>
        }
}

// SetModuleLogLevel sets the log level for a specific module.
func SetModuleLogLevel(module string, level zerolog.Level) <span class="cov0" title="0">{
        moduleLock.Lock()
        defer moduleLock.Unlock()
        moduleLogLevels[module] = level
}</span>

// GetModuleLogLevel gets the log level for a specific module.
func GetModuleLogLevel(module string) zerolog.Level <span class="cov0" title="0">{
        moduleLock.RLock()
        defer moduleLock.RUnlock()

        if level, ok := moduleLogLevels[module]; ok </span><span class="cov0" title="0">{
                return level
        }</span>

        <span class="cov0" title="0">return zerolog.GlobalLevel()</span>
}

// ModuleLogger wraps zerolog.Logger with per-module level control.
type ModuleLogger struct {
        *zerolog.Logger
        module         string
        selectiveMode  bool
        enabledModules map[string]bool
}

// NewModuleLogger creates a logger with module-specific configuration.
func NewModuleLogger(baseLogger *Logger, module string) *ModuleLogger <span class="cov0" title="0">{
        logger := baseLogger.With().Str("module", module).Logger()

        moduleLock.RLock()
        enabledModules := copyMap(activeDebugModules)
        moduleLock.RUnlock()

        return &amp;ModuleLogger{
                Logger:         &amp;logger,
                module:         module,
                selectiveMode:  selectiveDebugMode,
                enabledModules: enabledModules,
        }
}</span>

// Debug returns a debug event, filtered by module in selective mode.
func (m *ModuleLogger) Debug() *zerolog.Event <span class="cov0" title="0">{
        // In selective debug mode, filter by module
        if m.selectiveMode </span><span class="cov0" title="0">{
                if _, enabled := m.enabledModules[m.module]; !enabled </span><span class="cov0" title="0">{
                        disabledLogger := m.Logger.Level(zerolog.Disabled)
                        return disabledLogger.Debug()
                }</span>
        }

        <span class="cov0" title="0">if GetModuleLogLevel(m.module) &lt;= zerolog.DebugLevel </span><span class="cov0" title="0">{
                return m.Logger.Debug()
        }</span>

        <span class="cov0" title="0">disabledLogger := m.Logger.Level(zerolog.Disabled)
        return disabledLogger.Debug()</span>
}

// copyMap creates a copy of a map.
func copyMap(original map[string]bool) map[string]bool <span class="cov0" title="0">{
        copy := make(map[string]bool, len(original))
        for k, v := range original </span><span class="cov0" title="0">{
                copy[k] = v
        }</span>
        <span class="cov0" title="0">return copy</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package logger

import (
        "io"
        "regexp"
        "strings"
)

// Sensitive patterns to mask in logs.
var sensitivePatterns = []*regexp.Regexp{
        // Passwords in various formats
        regexp.MustCompile(`(?i)"(password|passwd|pwd)"\s*:\s*"([^"]+)"`),
        regexp.MustCompile(`(?i)(password|passwd|pwd)=([^\s&amp;]+)`),

        // API keys and tokens
        regexp.MustCompile(`(?i)"(token|api[-_]?key|secret|authentication[-_]?key)"\s*:\s*"([^"]+)"`),
        regexp.MustCompile(`(?i)(api[-_]?key|token|secret)=([^\s&amp;]+)`),

        // Authorization headers
        regexp.MustCompile(`(?i)(Authorization|X-API-Key):\s*(Bearer|Basic)?\s*([a-zA-Z0-9+/=._-]+)`),

        // Database connection strings
        regexp.MustCompile(`(?i)(postgres|postgresql|mysql)://([^:]+):([^@]+)@`),

        // UUIDs (potential keys)
        regexp.MustCompile(`([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})`),
}

// MaskSensitiveData masks sensitive information in log output.
func MaskSensitiveData(input string) string <span class="cov0" title="0">{
        masked := input

        for _, pattern := range sensitivePatterns </span><span class="cov0" title="0">{
                masked = pattern.ReplaceAllStringFunc(masked, func(match string) string </span><span class="cov0" title="0">{
                        parts := pattern.FindStringSubmatch(match)
                        if len(parts) &gt;= 3 </span><span class="cov0" title="0">{
                                value := parts[len(parts)-1]
                                maskedValue := maskValue(value)
                                return strings.Replace(match, value, maskedValue, 1)
                        }</span>
                        <span class="cov0" title="0">return match</span>
                })
        }

        <span class="cov0" title="0">return masked</span>
}

// maskValue masks a sensitive value keeping only first and last characters.
func maskValue(value string) string <span class="cov0" title="0">{
        if len(value) == 0 </span><span class="cov0" title="0">{
                return value
        }</span>

        <span class="cov0" title="0">if len(value) &lt;= 4 </span><span class="cov0" title="0">{
                return "***"
        }</span>

        // Keep first 2 and last 2 characters
        <span class="cov0" title="0">return value[:2] + "***" + value[len(value)-2:]</span>
}

// MaskingWriter wraps an io.Writer and masks sensitive data before writing.
type MaskingWriter struct {
        writer io.Writer
}

// NewMaskingWriter creates a new masking writer.
func NewMaskingWriter(w io.Writer) *MaskingWriter <span class="cov0" title="0">{
        return &amp;MaskingWriter{writer: w}
}</span>

// Write implements io.Writer interface with automatic masking.
func (m *MaskingWriter) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        masked := MaskSensitiveData(string(p))
        return m.writer.Write([]byte(masked))
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package types

import "time"

// Sensor represents a PRTG sensor with its metadata and current status.
type Sensor struct {
        ID                   int        `json:"id"`
        ServerID             int        `json:"server_id"`
        Name                 string     `json:"name"`
        SensorType           string     `json:"sensor_type"`
        DeviceID             int        `json:"device_id"`
        DeviceName           string     `json:"device_name,omitempty"`
        ScanningIntervalSecs int        `json:"scanning_interval_seconds"`
        Status               int        `json:"status"`
        StatusText           string     `json:"status_text"`
        LastCheckUTC         *time.Time `json:"last_check_utc,omitempty"`
        LastUpUTC            time.Time  `json:"last_up_utc"`
        LastDownUTC          *time.Time `json:"last_down_utc,omitempty"`
        Priority             int        `json:"priority"`
        Message              string     `json:"message,omitempty"`
        UptimeSinceSecs      *float64   `json:"uptime_since_seconds,omitempty"`
        DowntimeSinceSecs    *float64   `json:"downtime_since_seconds,omitempty"`
        FullPath             string     `json:"full_path,omitempty"`
        Tags                 string     `json:"tags,omitempty"`
}

// Device represents a PRTG device.
type Device struct {
        ID          int    `json:"id"`
        ServerID    int    `json:"server_id"`
        Name        string `json:"name"`
        Host        string `json:"host"`
        GroupID     int    `json:"group_id"`
        GroupName   string `json:"group_name,omitempty"`
        FullPath    string `json:"full_path,omitempty"`
        SensorCount int    `json:"sensor_count"`
        TreeDepth   int    `json:"tree_depth"`
}

// Group represents a PRTG group/probe.
type Group struct {
        ID          int    `json:"id"`
        ServerID    int    `json:"server_id"`
        Name        string `json:"name"`
        IsProbeNode bool   `json:"is_probe_node"`
        ParentID    *int   `json:"parent_id,omitempty"`
        FullPath    string `json:"full_path,omitempty"`
        TreeDepth   int    `json:"tree_depth"`
}

// DeviceOverview represents a complete device view with its sensors.
type DeviceOverview struct {
        Device       Device   `json:"device"`
        Sensors      []Sensor `json:"sensors"`
        TotalSensors int      `json:"total_sensors"`
        UpSensors    int      `json:"up_sensors"`
        DownSensors  int      `json:"down_sensors"`
        WarnSensors  int      `json:"warning_sensors"`
}

// SensorStatus represents common PRTG sensor status values.
const (
        StatusUnknown            = 0
        StatusUp                 = 3
        StatusWarning            = 4
        StatusDown               = 5
        StatusNoProbe            = 6
        StatusPausedByUser       = 7
        StatusPausedByDependency = 8
        StatusPausedBySchedule   = 9
        StatusUnusual            = 10
        StatusPausedByLicense    = 11
)

// GetStatusText returns human-readable status text.
func GetStatusText(status int) string <span class="cov0" title="0">{
        switch status </span>{
        case StatusUp:<span class="cov0" title="0">
                return "Up"</span>
        case StatusWarning:<span class="cov0" title="0">
                return "Warning"</span>
        case StatusDown:<span class="cov0" title="0">
                return "Down"</span>
        case StatusNoProbe:<span class="cov0" title="0">
                return "No Probe"</span>
        case StatusPausedByUser:<span class="cov0" title="0">
                return "Paused (User)"</span>
        case StatusPausedByDependency:<span class="cov0" title="0">
                return "Paused (Dependency)"</span>
        case StatusPausedBySchedule:<span class="cov0" title="0">
                return "Paused (Schedule)"</span>
        case StatusUnusual:<span class="cov0" title="0">
                return "Unusual"</span>
        case StatusPausedByLicense:<span class="cov0" title="0">
                return "Paused (License)"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package version

// AppVersion holds the current version of the application.
// This is set by main package at startup from build-time ldflags.
var AppVersion = "dev"

// Set updates the application version.
func Set(v string) <span class="cov0" title="0">{
        AppVersion = v
}</span>

// Get returns the current application version.
func Get() string <span class="cov0" title="0">{
        return AppVersion
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
